<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Hyperledger Fabric Map (WiP)</title>
<head>
<script type=module src=/IT_notes/map_v1.js></script>
<link rel='stylesheet' type='text/css' href='/IT_notes/map_v1.css' />
</head>

<body>

<div groupv>
<pre zoom>
<span title>Resources</span>
<span xsmall>External Links</span>
<a href='https://github.com/hyperledger/fabric'>GitHub</a>
<a href="https://hyperledger-fabric.readthedocs.io/">Docs</a>/
<a href="https://github.com/hyperledger/fabric/">GitHub</a>/
<a href="https://github.com/hyperledger/fabric/tree/release-1.2/protos">Protos</a>
<a href='https://godoc.org/github.com/hyperledger/fabric'>GoLang API DOC</a>
<a href='https://stackoverflow.com/questions/tagged/hyperledger-fabric'>Stack OverFlow</a>
git clone <a href='https://github.com/hyperledger/fabric-samples.git'>Fabric Samples@Github</a>
(<a href='https://github.com/hyperledger/fabric-samples/blob/release/first-network/'>First-network</a>)
<a href='https://hyperledger-fabric.readthedocs.io/en/latest/'>Fabric Doc Home</a>
<a href="https://hyperledger-fabric.readthedocs.io/en/latest/glossary.html">Glossary</a>
<a href="https://hyperledger-fabric.readthedocs.io/en/latest/releases.html">Release Notes</a>
<a href="https://hyperledger-fabric.readthedocs.io/en/latest/questions.html">Still Have Questions?</a>
<a href="https://hyperledger-fabric.readthedocs.io/en/latest/status.html">Status</a>

@[https://hyperledger-fabric.readthedocs.io/en/latest/architecture.html]
@[https://hyperledger-fabric.readthedocs.io/en/latest/Fabric-FAQ.html]
@[https://hyperledger-fabric.readthedocs.io/en/latest/glossary.html]
</pre>
<pre zoom>
  <span xsmall>Who is Who</span>
@[https://www.hyperledger.org/about/leadership]
</pre>

<pre zoom>
  <span xsmall>Bibliography</span>
<a href="https://www.safaribooksonline.com/library/view/hands-on-blockchain-with/9781788994521/">Hands-On Blockchain with Hyperledger</a>
</pre>

<pre zoom>
  <span xsmall>Development and contributing</span>
  <a href="https://hyperledger-fabric.readthedocs.io/en/latest/CONTRIBUTING.html">Contributions Welcome!</a>
  <a href="https://hyperledger-fabric.readthedocs.io/en/latest/MAINTAINERS.html">Maintainers</a>
  <a href="https://hyperledger-fabric.readthedocs.io/en/latest/jira_navigation.html">Using Jira to understand current work items</a>
  <a href="https://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/devenv.html">Setting up the development environment</a>
  <a href="https://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/build.html">Building Hyperledger Fabric</a>
  <a href="https://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/build.html#building-outside-of-vagrant">Building outside of Vagrant</a>
  <a href="https://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/build.html#configuration">Configuration</a>
  <a href="https://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/build.html#logging">Logging</a>
  <a href="Gerrit/lf-account.html">Requesting a Linux Foundation Account</a>
  <a href="Gerrit/gerrit.html">Working with Gerrit</a>
  <a href="Gerrit/changes.html">Submitting a Change to Gerrit</a>
  <a href="Gerrit/reviewing.html">Reviewing a Change</a>
  <a href="Gerrit/best-practices.html">Gerrit Recommended Practices</a>
  <a href="testing.html">Testing</a>
  <a href="Style-guides/go-style.html">Coding guidelines</a>
  <a href="Style-guides/go-style.html#generating-grpc-code">Generating gRPC code</a>
  <a href="Style-guides/go-style.html#adding-or-updating-go-packages">Adding or updating Go packages</a>
</pre>
</div>

<div groupv>
<span title>Building Blocks</span>
<pre bgorange zoom labels="101,network,aaa,chaincode,channel,db_engine,devops,">
<span xsmall>Network Schema</span>
CONSORTIUM NETWORK IS DEFINED THROUGH CHANNELs:

Network 1 ←────→ NºMembership Service Provider (MSP)º           Organization  1 ←────→ 1  MSP
                 ^ ─────────────────────────────────            ────────────              ────
         Ussually  - Abstracts away all cryptographic                                     MSPID
         just 1      mechanisms and protocols behind issuing                              priv.keys
                     and validating certificates, and user                                certificates
                     authentication.
                   - An MSP may define their own notion of
                     identity.

 ºPeerºN ←─────────────→ MºChannelº    1 ←────→ 1ºLedgerº   1 ←────────────────→ 1ºblockchainº
  ──────                   ───────                ──────                           ──────────
  -Roll :=                 -Ledger                Immutable blockchain             genesis block
   -ºCommiter(Proposer)º   -Members(Orgs)         current DDDBB state               Set of initial:
   -ºEndorser(signer)  º   -members               ("World State")                   - policies
                               .anchor_peers      Implemented as:                   - ACLs
  ─ledger copy             -chaincode apps 1 ←─┐  - LevelDB: (def) key/value        - members
   (one for each           -Ordering Nodes     │             (embedded in peer)     - anchor peers
    channel it belongs     -MSP (ACLs) *5      │  - CouchDB: JSON document store
    to)                    -Block policies     │             - enriched query capabi.
                                               │  - Features:
                                               │    - Query/update using key-based lookups,
                                               │      range and composite key queries queries
              Chaincode  N ←───────────────────┘    - Read-only queries using a rich query
              ─────────                               language (if using CouchDB as state
              - installed only on peers that need     database)
                read to assets                      - Read-only key-history queries
              - asset definitions                     (data provenance for key)
           Oº☞- Doesn't store state. Just logic.☜º  - Versiones transactions
                State stored in Channel-Ledger
                deployed in commiter nodes
              - code ("enforcing rules")
                to modify asset
              - id := peer - name - version
                (Ex: 'peer0.org.example.com-fabcar-1.0')
              - Invoqued by endorsers
              - executed in isolated Docker container

   VM/Phys 1 ←──→ N  Node
   Server            ────
                     - type:
                       - Client       : "FrontEnd" NodeJS, Java,... triggering new TX proposals
                                        in the Commiter peer
                       - Commiter Peer: commits TXs proposals and maintains a copy of the ledger
                       - Endorser Peer: (or endorser vs a particular chaincode). Signs TXs
                       - Orderer      : runs the communication service that implements an atomic
                                        or total order broadcast

 ┌───── CHANNEL SETUP ────────────────┐       ┌─ PEER SETUP ─┐        ┌─────── CHAINCODE SETUP  ────────┐    ┌── RUNNING APP ──┐
                                                                                                                     ┌─────┐
  0                    1                      2                        3                     4                5      ↓     │
  Create crytpo  ────→ Instantiate ─────────→ Join peers    ─────────→ Install chaincode  ─→ Initialize   ──→ Write/read ──┘
  material with        the channel            to the channel           chaincode             chaincode        to/from chaincode
  'cryptogen'          - create channel        ^                       on peers              ledger state        │
 +'crypto-config.yml'  - boostrapt orderer     │                       with endorsement                          ↓
                         ^                     │                       privileges                          Communitcate TX result
                         │                   - will be provided                                            to (service/application)
                         │                     commitment privilege
┌────────────────────────┴───────────┐       - endorsment if also
 INPUT                        OUTPUT           allowed by endorsement
 ─────                        ──────           policies
configtx.yml-→'configtxgen' -→-genesis.block
└────┬─────┘                 ─config.tx for
include input                 orderer+members
policies to configtxgen
</pre>

<pre zoom labels="101,aaa,msp,devops,channel">
<span xsmall>MSP⅋Channel Creation</span>
@[https://hyperledger-fabric.readthedocs.io/en/latest/msp.html]
MSP INSTANCE CONFIGURATION:
- specified locallyºat each peer/orderer in a channelº

- MSP instance ← instance := peers, orderer, client
  ────────────
   MSP.ID      ← unique "name" per MSP instance.
                 Ex. msp1, org2, and org3.divA
                 Used in policy membership rules

#################################################
# MSP setup on the peer⅋orderer side:           #
# (Default MSP:RFC5280/X.509 sign-verifi.based) #
#################################################

STEP 01) @peer|orderer nodes create next layout:

├─${FABRIC_CFG_PATH}/${MSPCONFIG_REL_PATH}/mspconfig as:
│ │
│ ├─ admincerts/                ← 1+ PEM      for admin-certificate
│ │                                (Authorized to modify initial root/CA list)
│ ├─ cacerts/                   ← 1+ PEM-root CA's certificate
│ ├─ intermediatecerts/    (opt)← 0+ PEM intermediate CA's certificate
│ ├─ crls/                 (opt)← CRLs
│ │                              CRL 1 ←→ 1 CA(Root/Intermediate)
│ │                              RºWARN:Identities never expireº
│ │                                     CRL is the only "revoke" method.
│ │
│ ├─ keystore/                  ← 1 PEM node-signing-key; (RºRSA keys are not supportedº)
│ ├─ signcerts/                 ← 1 PEM node-X.509 certificate
│ ├─ tlscacerts/           (opt)← 1+PEM TLS-certificate root (self-signed)
│ ├─ tlsintermediatecerts/(opt) ← 0+PEM TLS-certificate intermediate-CAs
│ │                                  ^^^^^^^^^^^^^^^
│ │                                  Used for connection, not for TX signing?
│ └─ config.yaml            ← 0|1 List of Organizational Units and identity classifications
│   └─┬───────┘                 (valid members will need to include a valid
│     │   Ex:                   OU in their X.509 certs.)
│     │                         Ex.Use Case: Multiple Org use:
│     │                                      - unique    root-of-trust
│     │                                      - different intermediate CAs
│    ┌v─────────────────────────────────────────────────────────────────────────
│    │OrganizationalUnitIdentifiers:                # ← MSP ID valid if carrying 1+ OUs
│    │  - Certificate: "cacerts/cacert1.pem"        # ← path relative to MSP root folder
│    │    OrganizationalUnitIdentifier: "commercial"
│    │  - Certificate: "cacerts/cacert2.pem"
│    │    OrganizationalUnitIdentifier: "administrators"
│    │ NodeOUs:
│    │   Enable: true   #  enables/disable ID-classification)
│    │                     if true it implies that admins X.509 certs must present
│    │                     ClientOUIdentifier. (Client rool)
│    │   ClientOUIdentifier:                        # ← Clients Submit TXs, queries peers,...
│    │     Certificate: "cacerts/cacert.pem"
│    │     OrganizationalUnitIdentifier: "clientOU" # ← must match the OU of client x509 cert
│    │   PeerOUIdentifier:                          # ← Peers endorser(sign)|commit(store) TXs
│    │     Certificate: "cacerts/cacert.pem"
│    │     OrganizationalUnitIdentifier: "peerOU"   # ← must match the OU of peer   x509 cert
│    └──────────────────────────────────────────────────────────────────────────
│
│                                    SET/OVERRIDE
│                                    ────────────
├─${FABRIC_CFG_PATH}/core.yaml     ← mspConfigPath=${MSPCONFIG_REL_PATH}
│                    ^^^^^^^^^       localMspId="...."
│      endorser|commiter peers       'CORE' ENV.VAR
│                 (vs orderers)
│
│
└─${FABRIC_CFG_PATH}/orderer.yaml  ← LocalMSPDir=${MSPCONFIG_REL_PATH}
                                     localMspId
                                     'ORDERER' ENV.VAR

STEP 03) Provide the orderer/s with the configuration  block
    ("genesis block" with list of admin/node certs, MSP.IDs, ...) of the
    system channel (vs application channel.). Used to authenticate future
    application channel creation TX requests.
    application channels config. blocks only need the verification components
    of MSPs governing the channel.

REF: @[https://hyperledger-fabric.readthedocs.io/en/latest/configtx.html]
|channel|                 |channel  |                      channel
|config | → configtxgen → |config TX|     ──|orderer| ─→   configuration
                           ──┬──────        └───┬───┘      block
                 ┌───────────┘                  │          └┬──────────┘
                 ├─configtx signatures          │           ├─ One single TX
                 │ must match that of           │           └─ 1st conf.bck = "genesis"
                 │      the policy              │
                 ├─configtx.type :=             │
                 │    headertype_config         │
                 │ ││ headertype_config_update  │    Ex:
                 │    └────────┬─────────────┘  │ ┌─ INITIAL STATE
                 │ orderer assumes it is a      │ │  ─────────────────────────
                 │ creation request if channel  │ │    Channel:        (version 0)
                 │ does not exists.             │ │      Orderer       (version 0)
                 └─ versioned read/write set  ←─│─┘      Application   (version 3)
                                                │           OºOrg1º    (version 2)
                                                │
                                                │    configtx read/write_set
                                                │    ─────────────────────────────
                                                │    ºread_setº
                                                │      Channel:        (version 0)
                                                │        Application:  (version 3)
                                                │    ºwrite_setº
                                                │      Channel:        (version 0)
                                                │          Application:(version 3)
                                                │              OºOrg1º (version 3)
                                                │
┌───────────────────────────────────────────────┘
└─ SEQ. DIAGRAM:
   ???     → orderer: CONFIG_UPDATE request
   orderer → orderer: extract Consortium value from top level group.
   orderer → orderer: Verify:
                      - organizations in /Application is subset of Consortium orgs.
                      - ApplicationGroup.version == 1
                      - if (consortium has members)
                          verify new channel also has application members
   orderer → orderer: create template-config as:
                      Orderer group =  Orderer group from ordering system channel
                      Application group =  newly specified members
                      Application group.mod_policy = ChannelCreationPolicy specified in consortium config
   orderer → orderer: new CONFIG TX = apply CONFIG_UPDATE as update new template-config
                      CONFIG_UPDATE applies modifications to the Application group (v.1)
                      validating updates against the ChannelCreationPolicy.
                      mod policy for any other modifications (org's anchor peers,...)
                      will be invoked.
   orderer → ordering: new CONFIG TX
             system
             channel

See also:
  @[https://hyperledger-fabric.readthedocs.io/en/latest/msp.html#best-practices]
  @[https://github.com/hyperledger/fabric/blob/master/protos/common/configtx.proto]
</pre>

<pre zoom labels="101,aaa,endorsement_policies">
<span title>Endorsement policies</span>
@[https://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html]
@[https://github.com/hyperledger/fabric/blob/master/docs/source/policies.rst]
- Endorsement policies are the circuit of signatures needed to consider a TX as valid.
- Used everywhere to specify who can change configuracion, deploy new chaincode,
  invode deployed chaincode, ...
- generally reside in channel config. blocks (also in chaincodes)
- Policy Types:
  -    SignaturePolicy: combination of evaluation rules for MSP Principals.
                       (AND|OR|... circuit signature)
  - ImplicitMetaPolicy: valid in configuration context.
                        sum-of SignaturePolicies deeper in config.hierarchy


($ docker exec -it cli bash)
$ peerºchaincodeºBºinstantiateº \
  -C ˂channelid˃ -n myChainCode \
 Oº-P "AND('Org1.member', 'Org2.member', 'Org3.member'     )"º
   └┬┘ "OR ('Org1.member', 'Org2.member'                    )"
    │  "OR ('Org1.member', AND('Org2.member', 'Org3.member'))"
    │  ...
  if ommited default policy is:
Oº"any member of any existing organization in the channel"º
                     ^^^^^^^^ 
                     new organizations will not be able to commit TXs endorsed by themself. 
                     (but in general they will be able to query read-only data)


ºCHANNEL CONFIGURATION HIERARCHY EXAMPLEº
 Channel:                         ← Implicit Policy apply to groups:
   Policies:
     Readers ✔                    ←  leafs ✔ are SignaturePolicies
     Writers ✔
     Admins  ✔
   Groups:
     Orderer:
       Policies:
         Readers ✔ 
         Writers ✔
         Admins  ✔
       Groups:
         OrdereringOrganization1:  ← 1/1 Ordering Org
           Policies:
             Readers ✔
             Writers ✔
             Admins  ✔
     Application:
       Policies:
         Readers ✔
         Writers ✔
         Admins  ✔
       Groups:
         ApplicationOrganization1: ← 1/2 Application Org
           Policies:
             Readers  ✔
             Writers  ✔
             Admins   ✔
         ApplicationOrganization2: ← 2/2 Application Org
           Policies:
             Readers ✔
             Writers ✔
             Admins  ✔
</pre>

<pre bgorange zoom labels="101,transaction,consensus">
<span xsmall>TX Types (Config/Deploy/Invoque)</span>
ºDeploy TXº                    ºInvoke TXº                       ºConfig TXº
 - creates new chaincode.       - Trigger action on chaincode,    - Modify Channel policies,...
 - takes program as parameter.    most probably modifying the
 - Specifies endorsement          Ledger state on success. 
   policy for the chaincode.
   ('-P' flag is cli)
<hr/>
<span xsmall>TX FLOW</span>
<span xsmall>(Consensus)</span>
@[https://hyperledger-fabric.readthedocs.io/en/latest/txflow.html]
[STEP 1 Prepare TX proposal]
client   → client    : - New Invoke-TX (proposal) 
                           ---------
                           - TX.chaincode
                           - TX.input 
[STEP 2 Prepare TX proposal]
client    → client    : Package TX-proposal
client    → client    : SignedTX= Sign(Packaged-TX-proposal, submitter credentials)
client    → Channel   : SignedTX
Channel   → endorser  : Signed-packaged-TX-proposal
            ^^^^^^^^
       (endorser list actually)
endorser  → endorser  : Verify:
                        - TX proposal is well formed
                        - not repeated (replay-attack)
                        - signature is OK agains channel MSP
                        - submitter is write-authorized by
                          channel's policy
endorser  →  Chaincode: exec TX.chaincode(TX.input) against
                             current database-state
Chaincode →  endorser : TX.result = [ response value, read set, write set ]

[STEP 3 Wait for endorsement]
client    →  client   : - wait until "enough" messages and signatures on
                          (TRANSACTION-ENDORSED, tid, º, º) statements to
                          conclude that the TX proposal is endorsed. (may
                          involve one+ round-trips with endorsers).
                          (abort if not enought  endorsements are collected) 
                       
client    → commt.peer:(TX.proposal, TX.result, endorsing sign._list)
commt.peer→ orderer   :(TX.proposal, TX.result, endorsing sign._list)
orderer   →   orderer : - Order chronologically
                        - create blocks of TX
                        - Serializability isolation (default) 

orderer   →   peers   : TX block
peers     →   peers   : validate block
peers     →   peers   : Update ledger
peers     →   Client  : event "TX appended to chain"
</pre>
<pre zoom labels="channel,aaa">
<span xsmall>Update Channel (Add Org,...)</span>
@[https://hyperledger-fabric.readthedocs.io/en/latest/channel_update_tutorial.html]
Ex.:Adding an Org to a Channel

ºPRE-SETUPº
- Org3's crypto artifacts must exists before proceding.
$ cryptogen generate \       ←RºWARNº:cryptogen is designed for development
  --config=org3-crypto.yaml          (vs production) enviroments
  --output="../organizations"
            ^^^^^^^^^^^^^^^^ 
          - Org3 keys and Certs will be placed in
            ../organizations/peerOrganizations/


ºADD-to-Channelº
GºSTEP 1)ºEdit configtx.yaml to add:  GºSTEP 2)ºExecute configtxgen
  - policy definitions for Org3         $ export FABRIC_CFG_PATH=...
  - certs:                              $ configtxgen -printOrg Org3MSP \
    - root (of-trust) CA cert             | cat ˃.../org3.ex.com/org3.json
    - TLS(gossip protocol) root cert,                            └───┬───┘
      identifying Org3                   ┌───────────────────────────┘
    - admin user cert                    └ must contains same info provided in STEP 1):
                                           - policy definitions for Org3
                                           - base64 encoded certs:
                                             - root (of-trust) CA cert
                                             - TLS(gossip protocol) root cert, identifying Org3 
                                             - admin user cert
 
GºSTEP 3)ºadd org3(.json) to channel:
  3.1) bootup cli
    (probably docker-compose -f ...yaml up)
    ...
    creating peer0.org3 ... done ← blockchain node
  
  3.2) fetch current application channel 
    3.2.1) switch environment to impersonate org1 admin user. export next variables:
    core_peer_localmspid="org2msp"
    core_peer_tls_rootcert_file=.../org1..../peers/peer0.org1.ex.com/tls/ca.crt
        core_peer_mspconfigpath=.../org1..../users/admin@org1.ex.com/msp
              core_peer_address=peer0.org1.ex.com:9051
  
    3.2.2) fetch info:
    $ peer channel fetch config \
      -c $channel_name \
      -o orderer.ex.com:7050 --tls --cafile $orderer_ca \
      current_channel_config.pb
    
    convert to json:
    $ configtxlator proto_decode \
      --input current_config_block.pb \
      --type  common.block | \
      jq ".data.data[0].payload.data.config" ˃ \  ← remove headers, metadata, creator signatures,
     ºcurrent_channel_config.jsonº                    (jq: standard unix command to parse json data)
    
    
  3.3) add org3 crypto material
    # using standard unix tool 'jq' with flag '-s' (append)
    $ jq -s \  
      '.[0] * {"channel_group":{"groups":{"application":{"groups": {"org3msp":.[1]}}}}}' \
      current_channel_config.json  \
      ...org3.json ˃ \
     ºnew_channel_config.jsonº
  
    # convert back to protobuf:
    for base in  current_channel_config new_channel_config ; do
      configtxlator proto_encode \
        --input $base.json \
        --type common.config \
        --output $base.pb
    done
  
  3.4) calculate diff between original and new configs:
    $ configtxlator compute_update \
      --channel_id $channel_name \
      --original current_channel_config.pb \
      --updated      new_channel_config.pb \
      --outputºorg3_diff_update.pbº
  
    # convert to json:
    $ configtxlator proto_decode \
      --inputºorg3_diff_update.pbº\
      --type common.configupdate | 
      jq . ˃ºorg3_diff_update.jsonº
  
  3.5) wrap diff into envelope message:
       (put header fields back in place)
       $ json=""
       $ json="${json}{"
       $ json="${json}\"payload\":{"
       $ json="${json}\"header\":{\"channel_header\":{\"channel_id\":\"'$channel_name'\", \"type\":2}},"
       $ json="${json}\"data\":{\"config_update\":'$(cat org3_update.json)'}"
       $ json="${json}}"
       $ json="${json}}"
       $ echo $json ˃ /tmp/diff.json
       $ cat /tmp/diff.json \
           | jq . ˃ºorg3_diff_update_in_envelope.jsonº
  
       # convert back to protobuf:
       $ configtxlator proto_encode \
         --input  ºorg3_diff_update_in_envelope.jsonº \
         --type common.envelope \
         --output ºorg3_diff_update_in_envelope.pbº
  
  3.6) sign and submit the config update
  - collect required admin users signatures before submitting 
    the tx.
    # sign as org1 admin member
    $ peer channel signconfigtx -f org3_update_in_envelope.pb
  
    # switch environment to impersonate org2 admin user. export next variables:
    core_peer_localmspid="org2msp"
    core_peer_tls_rootcert_file=.../org2..../peers/peer0.org2.ex.com/tls/ca.crt
        core_peer_mspconfigpath=.../org2..../users/admin@org2.ex.com/msp
              core_peer_address=peer0.org2.ex.com:9051
    # sign now as org2 admin member
    $ peer channel signconfigtx -f org3_update_in_envelope.pb
  
  3.7) issue an tx-proposal
    $ peer channel update -fºorg3_diff_update_in_envelope.pbº \
       -c $channel_name \
       -o orderer.ex.com:7050 \
       --tls --cafile $orderer_ca
    → ...  [channelcmd] update -˃ info 002 successfully submitted channel update
  
    (at this point, channel-configuration includes org3, and peers attached
     to it, can now join the channel)
  
GºSTEP 4) join(sync ledger) org3 to the channel:
    4.1) bootup Ord3 peer node if not running.
    4.2) In cli node: 
    # switch environment to impersonate org3 admin user.
    core_peer_localmspid="org3msp"
    core_peer_tls_rootcert_file=.../org3..../peers/peer0.org3.ex.com/tls/ca.crt
        core_peer_mspconfigpath=.../org3..../users/admin@org3.ex.com/msp
              core_peer_address=peer0.org3.ex.com:9051
  
    # request ordered the genesis block. it must work now:
    $ peer channel fetch 0 \
      -o orderer.ex.com:7050 --tls --cafile $orderer_ca \ 
      -c $channel_name  \
      mychannel.genesis.block 
  
   # use genesis block to to join (sync ledger) the peer to the channel. 
   $ peer channel join -b mychannel.block 
</pre>


<pre zoom labels="consensus,transaction">
<span xsmall>read-write   </span>
<span xsmall>set semantics</span>
@[https://hyperledger-fabric.readthedocs.io/en/latest/readwrite.html]

tx simulation:  read set + write set are prepared
read  set [("key", "value in" , "version"   )] → tx → [("key", "value out", "version++" )]
 * "value out" or isdelete=true

example:
consider a set of five ordered transactions
   (t1 → t2 → t3 → t4 → t5)
simulated on the same snapshot of the world state:

initial state:
   [/* key value  version */
     ( k1 ,  1  ,   v1   ),
     ( k2 ,  2  ,   v2   ),
     ( k3 ,  3  ,   v3   ),
     ( k4 ,  4  ,   v4   ),
     ( k5 ,  5  ,   v5   )]
_________________________________________
t1 → write k1 → (k1,2,v1')
     write k2 → (k2,2,v2')
   result:
     validation ok (no reads)
_________________________________________
t2 → read(k1,1,v1)
      write k3 → (k3,3,v3')
   result:
     validation error  (reads k1 v1 ˂ current version v1')
_________________________________________
t3 → write  k2 → (k2, v2'')
   result:
     validation ok (no reads)
     k2 updated to (k2,3,v2'')
_________________________________________
t4 → write(k2, v2'''), read(k2)
   result:
     validation error  (reads k2 v1 ˂ current v2'')
_________________________________________
t5 → write k6 → (k6, v6')
      read(k5)
   result:
     validation ok (k5,v1 still in version v1 )
_________________________________________

note: transactions with multiple read-write sets are not yet supported.
</pre>
<pre zoom labels="101,service_discovery,network">
  <a xsmall href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/discovery-overview.html">service discovery</a>
- service discovery runs on peers. external apps will choose a well-known group of trusted peers
  (probably a peer owned by the organization).
 - provides (dynamically changing) information to (external) application:
   - cas
   - orderers and peers tls certs on the channel
   - ip addresses and port numbers
   - relevant endorsement policies
   - which peers have the chaincode installed (so the application knows which peers to send chaincode proposals to)
   - which peers are already synchronized (their ledgers upated) avoiding submiting to "delayed" peers
     (tx will be invalidated upon commit wasting resources)
   - which peers are needed for endorsement given a channel and a chaincode id:
     - discovery service will compute a descriptor comprised of two objects:

                   | description                              | example
      -------------+------------------------------------------+------------------------------------
       layout      | peer group list                          | layouts : [                       ←"endorsement policy requires
                   | and corresponding amount                 |   quantitiesbygroup:                a signature from one peer
                   | of peers from each group                 |    { "org1": 1, "org2": 1, }        in org1 ºandº one peer in org2"
                   | which should be selected                 | ]                                   (list instead of map for ºorº?)
      -------------+------------------------------------------+------------------------------------
       group2peer  | map group in the layout                  | endorsersbygroups : {              ←names of available peers in
                   | to the peers of the channel              |   “org1”: [peer0.org1, peer1.org1], those orgs who can endorse
                   | in practice, each group would            |   “org2”: [peer0.org2, peer1.org2]
                   | most likely be peers that represent      | }
                   | individual organizations, but because    |
                   | the service api is generic and ignorant  |
                   | of organizations this is just a "group". |
      -------------+------------------------------------------+------------------------------------

       - fabric sdk will selects a random (for "or") layout from the list
       - then a set of peers based on the criteria specified on the client side
         (prefer peers with higher ledger heights, exclude offline peers, ...), or
         a random peer if there is no "favourite".


discovery service can provide answer for:
  - configuration query: returns the mspconfig of all organizations in the channel
      along with the orderer endpoints of the channel.
  - peer membership query: returns the peers that have joined the channel.
  - endorsement query: returns an endorsement descriptor for given chaincode(s) in a channel.
  - local peer membership query: returns the local membership information of the peer
    that responds to the query. by default the client needs to be an administrator for the
    peer to respond to this query.

<a xsmall href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/discovery-cli.html">discovery cli</a>
pre-setup: persist tls/key/cert/msp config:

$ discover --configfile bºconf.yamlº \
    --peertlsca tls/ca.crt \
    --userkey msp/keystore/ea4f6a38ac7057b6fa9502c2f5f39f182e320f71f667749100fe7dd94c23ce43_sk \
    --usercert msp/signcerts/user1\@org1.example.com-cert.pem \
    --msp org1msp saveconfig

bºconf.yamlº will be created for reuse in next commands:

$ cat bºconf.yamlº
version: 0
tlsconfig:
  certpath: ""
  keypath: ""
  peercacertpath: /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerorganizations/org1.example.com/users/user1@org1.example.com/tls/ca.crt
  timeout: 0s
signerconfig:
  mspid: org1msp
  identitypath: /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerorganizations/org1.example.com/users/user1@org1.example.com/msp/signcerts/user1@org1.example.com-cert.pem
  keypath: /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerorganizations/org1.example.com/users/user1@org1.example.com/msp/keystore/ea4f6a38ac7057b6fa9502c2f5f39f182e320f71f667749100fe7dd94c23ce43_sk

_______________________________________________________________________________
$ discover --configfile bºconf.yamlº ºpeersº --channel mychannel  --server peer0.org1.example.com:7051
[
 { "mspid": "org2msp", "ledgerheight": 5, "endpoint": "peer0.org2.com:7051", "identity": "-----begin cert...", "chaincodes": [ "mycc" ] },
 { "mspid": "org2msp", "ledgerheight": 5, "endpoint": "peer1.org2.com:7051", "identity": "-----begin cert...", "chaincodes": [ "mycc" ] },
 { "mspid": "org1msp", "ledgerheight": 5, "endpoint": "peer0.org1.com:7051", "identity": "-----begin cert...", "chaincodes": [ "mycc" ] },
 { "mspid": "org1msp", "ledgerheight": 5, "endpoint": "peer1.org1.com:7051", "identity": "-----begin cert...", "chaincodes":    null }
                                                                                          ^enrollment certificate of peer
                                                                                           use "$ openssl x509 -text -noout" to print
]

mapping from msp ids to orderer endpoints, as well as the fabricmspconfig which can be used to verify all peer and orderer nodes by the sdk:

$ discover --configfile bºconf.yamlº ºconfigº --channel mychannel --server peer0.org1.example.com:7051
{
  "msps": {
    "ordererorg": {"name": "orderermsp", "root_certs": [base64], "admins": [base64], "crypto_config": { "signature_hash_family": "sha2", "identity_identifier_hash_function": "sha256" }, "tls_root_certs": [base64] },
    "org1msp":    {"name": "org1msp",    "root_certs": [base64], "admins": [base64], "crypto_config": { "signature_hash_family": "sha2", "identity_identifier_hash_function": "sha256" }, "tls_root_certs": [base64],
                   "fabric_node_ous": { "enable": true,
                     "client_ou_identifier": { "certificate": base64, "organizational_unit_identifier": "client" },
                     "peer_ou_identifier"  : { "certificate": base64, "organizational_unit_identifier": "peer" }
                   }
    },
    "org2msp": {...},
    ...
  },
  "orderers": { "ordererorg": { "endpoint": [ { "host": "orderer.example.com", "port": 7050 } ] } }
}

$ discover --configfile bºconf.yamlº ºendorsersº --channel mychannel  --server peer0.org1.example.com:7051 --chaincode mycc
[
    {
        "chaincode": "mycc",
        "endorsersbygroups": {
            "g0": [ { "mspid": "org1msp", "ledgerheight": 5, "endpoint": "peer0.org1.example.com:7051", "identity": "-----begin cert..." } ],
            "g1": [ { "mspid": "org2msp", "ledgerheight": 5, "endpoint": "peer1.org2.example.com:7051", "identity": "-----begin cert..." },
                    { "mspid": "org2msp", "ledgerheight": 5, "endpoint": "peer0.org2.example.com:7051", "identity": "-----begin cert..." } ]
        },
        "layouts": [ { "quantities_by_group": { "g0": 1, "g1": 1 } } ]
    }
]
</pre>

<pre zoom labels="network">
<span xsmall>gossip data dissemination protocol</span>
@[https://hyperledger-fabric.readthedocs.io/en/latest/gossip.html]
Gossip data dissemination protocol

- Each gossiped message is signed. 
- gossip-based data dissemination protocol primary functions:
  - Manages peer discovery and channel membership.
  - Disseminates ledger data across all peers on a channel.
  - Bring newly connected peers up to speed by allowing peer-to-peer state 
    transfer update of ledger data.

- Gossip: peer receives constant flux of messages from other peers 
          and then forward them to a number of randomly selected peers 
          on the channel.
- leader peer start the dissemination of new blocks

Leader election can be:
- Static : decided bysystem administrator
- Dynamic: consensus.

-ºAnchor peers:º
 - Used by gossip to make sure peers in different organizations 
   know about each other.

- If you are using gossip, you will typically configure all the peers in your 
  organization to point to an initial set of bootstrap peers (you can specify a 
  space-separated list of peers).

ENV.VARS:
CORE_PEER_GOSSIP_BOOTSTRAP="a list of peer endpoints within the peer's org"
CORE_PEER_GOSSIP_EXTERNALENDPOINT="the peer endpoint, as known outside the org"

Gossip include also keep-alive messages.
</pre>



</div>

<div groupv>
<span title>chaincode("smartcontract")</span>
<pre zoom labels="101,chaincode">
<span xsmall>chaincode 4 devs</span>
@[http://hyperledger-fabric.readthedocs.io/en/latest/chaincode4ade.html]
- golang/nodejs/java(planned) program implementing a mandatory interface "chaincode":
  (<a href="https://godoc.org/github.com/hyperledger/fabric/core/chaincode/shim#chaincode">go</a>,
   <a href="https://fabric-shim.github.io/chaincodeinterface.html">node.js</a>) and business logic agreed by members
    in particular:
  init  : triggered by incomming "instantiate"/"upgrade" tx proposals
          chaincode will perform state initialization or upgrade/migration to new version

 invoke : triggered by incomming "invoke" tx proposals
          used to access ("get") and modify ("set") the ledger, and to make
          invocations between chaincodes

  - the other shim standard interface is "chaincodestubinterface", used to access and modify
    the ledger.
   (<a href="https://godoc.org/github.com/hyperledger/fabric/core/chaincode/shim#chaincodestubinterface">go</a>,
    <a href="https://fabric-shim.github.io/chaincodestub.html">node.js</a>)
  - runs in a secured docker container isolated from endorsing peer process</li>
  - restricted to permissions, a chaincode may invoke another chaincode in the
    same channel (read/write) or different channels (read only)</li>

  simple asset chaincode ("sacc")
$ sudo yum install libtool-ltdl-devel # or similar in ubuntu/... +
$ mkdir -p $gopath/src/sacc &amp;&amp; cd $gopath/src/sacc +
$ edit ($gopath/src/sacc)"sacc.go"
package main

import (
    "fmt"
    "github.com/hyperledger/fabric/core/chaincode/shim" // mandatory interface
    "github.com/hyperledger/fabric/protos/peer"
)

// model structs
type simpleasset struct {
}

// --------------------------------------------------
// mandatory interface implementation (init,  invoke)
// --------------------------------------------------

    func (t *simpleasset) init(stub shim.chaincodestubinterface) peer.response {
      args := stub.getstringargs() // step 1: get args from tx proposal

      if len(args) != 2 { // preconditions
        return shim.error("incorrect arguments. expecting a key and a value")
      }

      err := stub.putstate(args[0], []byte(args[1])) // store key and value on ledger
      if err != nil {
        return shim.error(fmt.sprintf("failed to create asset: %s", args[0]))
      }
      return shim.success(nil)

    }

    // method may create a new asset by specifying a new key-value pair.
    func (t *simpleasset) invoke(stub shim.chaincodestubinterface) peer.response {
        // extract the function and args from the transaction proposal
        fn, args := stub.getfunctionandparameters()

        var result string
        var err error
        if fn == "set" { result, err = set(stub, args)
        } else         { result, err = get(stub, args) }
        if err != nil  { return shim.error(err.error()) }

        return shim.success([]byte(result)) // return the result as success payload
    }

// --------------------------------------------------
// business logic
// --------------------------------------------------
    func set(stub shim.chaincodestubinterface, args []string) (string, error) {
        if len(args) != 2 { return "", fmt.errorf("incorrect arguments. expecting a key and a value") }

        err := stub.putstate(args[0], []byte(args[1]))
        if err != nil { return "", fmt.errorf("failed to set asset: %s", args[0]) }
        return args[1], nil
    }

    // get returns the value of the specified asset key
    func get(stub shim.chaincodestubinterface, args []string) (string, error) {
        if len(args) != 1 { return "", fmt.errorf("incorrect arguments. expecting a key") }

        value, err := stub.getstate(args[0])
        if err != nil { return "", fmt.errorf("failed to get asset: %s with error: %s", args[0], err) }
        if value == nil { return "", fmt.errorf("asset not found: %s", args[0]) }
        return string(value), nil

// --------------------------------
// standar go-lang main entry point
// --------------------------------
func main() {
    if err := shim.start(new(simpleasset)); err != nil {
            fmt.printf("error starting simpleasset chaincode: %s", err)
    }
}

<span xsmall>building chaincode</span>
$ cd ...
$ go get -u github.com/hyperledger/fabric/core/chaincode/shim
$ go build

<span xsmall>testing (dev mode)</span>
in "prod mode" chaincode is run on the peer.
in "dev mode", chaincode is built and started by the user.

create an "end-to-end" test: install chaincode on peer →, instantiate it , invoke method → querying status:
step 1: start "dev mode" with pre-built orderer/channel artifacts in examples/chaincode-docker-devmode
$ cd chaincode-docker-devmode

┌───────────────────────────────┬─────────────────────────────────────────┬────────────────────────────────────┐
│step 1.1: terminal 1           │ step 1.2: terminal 2                    │ step 1.3: terminal 3               │
│                               │ put chain code in listen mode           │ install on peer, invoke, query     │
├───────────────────────────────┼─────────────────────────────────────────┼────────────────────────────────────┤
│start the network:             │ build and start the chaincode           │ use the chaincode                  │
│- singlesamplemspsolo orderer  │ $ docker exec -it chaincode bash        │ - install the chaincode            │
│- peer in "dev mode"           │ root@/.../chaincode # \                 │                                    │
│- chaincode env. container     │   cd sacc ⅋⅋ go build                   │ $ docker exec -it cli bash         │
│- cli container ("shell")      │                                         │                                    │
│                               │ # run the chaincode:                    │ root@/... # \                      │
│$ docker-compose -f \          │ root@/.../chaincode # \                 │   peer chaincode install \         │
│  docker-compose-simple.yaml up│     core_peer_address=peer:7052 \       │   -p chaincodedev/chaincode/sacc \ │
│                               │     core_chaincode_id_name=ºmyccº:0 \   │   -n ºmyccº -v 0                   │
│                               │     ./sacc                              │ root@/... # \                      │
│                               │ (check logs for successful registration)│   peer chaincode instantiate \     │
│                               │                                         │   -n ºmyccº -v 0 \                 │
│                               │ # note: chaincode is not yet associated │   -c '{"args":["a","10"]}' \       │
│                               │ # with any channel                      │   -c gºmychannelº                  │
│                               │                                         │ # now invoke to change "a" → "20"  │
│                               │                                         │ root@/... # \                      │
│                               │                                         │   peer chaincode invoke \          │
│                               │                                         │   -n ºmyccº \                      │
│                               │                                         │   -c '{"args":["set", "a", "20"]}' │
│                               │                                         │   -c gºmychannelº                  │
│                               │                                         │                                    │
│                               │                                         │ # query to check final value       │
│                               │                                         │ root@/... # \                      │
│                               │                                         │   peer chaincode query \           │
│                               │                                         │   -n ºmyccº                        │
│                               │                                         │   -c '{"args":["query","a"]}'      │
│                               │                                         │   -c gºmychannelº                  │
└───────────────────────────────┴─────────────────────────────────────────┴────────────────────────────────────┘

notes:
you can easily test different chaincodes by adding them to the chaincode subdirectory and relaunching your network.
at this point they will be accessible in your chaincode container.

º(optional) chaincode value encryptionº
- encryption is achieved by leveraging the
  <a href="https://github.com/hyperledger/fabric/tree/master/core/chaincode/shim/ext/entities">entities extension</a>
  which is a <a href="https://godoc.org/github.com/hyperledger/fabric/bccsp">bccsp</a> wrapper with commodity
  factories and functions to perform cryptographic operations such as encryption and elliptic curve digital signatures.
  for example, to encrypt, the invoker of a chaincode passes in a cryptographic
  key via the transient field. the same key may then be used for subsequent
  query operations, allowing for proper decryption of the encrypted state values.
  see <a href="https://github.com/hyperledger/fabric/tree/master/examples/chaincode/go/enccc_example">examples</a>
  with specific attention to the utils.go helper program.

<span xsmall>shim api</span>
- shim api (go package) allows the chaincode to access its state variables,
  transaction context and call other chaincodes.
+-------------------------------------+---------------------------------------------------------------
|getstate(key string) ([]byte, error) | returns the value of the `key` from the worldstate.
|                                     | if the key does not exist in the worldstate the function
|                                     | returns (nil, nil).
|                                     | the function does not read data from the writeset and
|                                     | hence uncommitted values modified by putstate are not returned.
+-------------------------------------+---------------------------------------------------------------
|putstate(key string, value []byte)   | records the specified `key` and `value` into the writeset.
|                                     | the function does not affect the ledger until the transaction
|                                     | is committed into the ledger.
+-------------------------------------+---------------------------------------------------------------
|delstate(key string) error           | marks the the specified `key` as deleted in the writeset.
|                                     | the key will be marked as deleted and removed from worldstate
|                                     | once the transaction is committed into the ledger.
+-------------------------------------+---------------------------------------------------------------
|gettxid() string                     | returns an unique id of the transaction proposal.
+-------------------------------------+---------------------------------------------------------------
|getchannelid() string                | returns an id of the channel the transaction proposal was sent to.
+-------------------------------------+---------------------------------------------------------------
|invokechaincode(                     | calls an invoke function on a specified chaincode, in the context
| chaincodename string, args [][]byte,| of the current transaction.
| channel string) pb.response         | - if the invoked chaincode is on the same channel, the readset and
|                                     |   writeset will be added into the same transaction.
|                                     | - if the invoked chaincode is on a different channel,
|                                     |   the invocation can be used only as a query.
+-------------------------------------+---------------------------------------------------------------
|func gethistoryforkey(key string)    | returns a list of historical states, timestamps and transactions ids.
|  (historyqueryiteratorinterface, error)
+-------------------------------------+---------------------------------------------------------------
|func getcreator() ([]byte, error)    | returns the identity of the user submitting the transaction proposal.
+-------------------------------------+---------------------------------------------------------------
|gettransient()                       | returns a map of fields containing cryptographic material which
|   (map[string][]byte, error)        | may be used to implement custom privacy layer in the chaincode.
+-------------------------------------+---------------------------------------------------------------
|getbinding() ([]byte, error)         | returns data which can be used to enforce a link between
|                                     | application data and the transaction proposal.
+-------------------------------------+---------------------------------------------------------------
|getdecorations() map[string][]byte   | returns data produced by peer decorators which modified the chaincode input.
+-------------------------------------+---------------------------------------------------------------
|getsignedproposal()                  | returns data elements of a transaction proposal.
|    (*pb.signedproposal, error)      |
+-------------------------------------+---------------------------------------------------------------
|gettxtimestamp()                     | returns a timestamp of the transaction creation
|    (*timestamp.timestamp, error)    | by the client. the timestamp is consistent across all endorsers.
+-------------------------------------+---------------------------------------------------------------
|setevent(name string, payload []byte)| sets an event attached to the transaction proposal response.
|    error                            | this event will be be included in the block and ledger.
+-------------------------------------+---------------------------------------------------------------
</pre>

<pre zoom labels="chaincode,advanced">
<span xsmall>managing external</span>
<span xsmall>dependencies </span>
<span xsmall>(non standard go libs)</span>
$ govendor init
$ govendor add +external               // add all external package, or
$ govendor add github.com/external/pkg // add specific external package
</pre>

<pre zoom labels="101,network">
  <a xsmall href='http://hyperledger-fabric.readthedocs.io/en/latest/build_network.html'>build your first network</a>,
building your first network (fabric-samples/first-network, byfn.sh)

1 "solo" ordering service:
two orgs x 2 peers(nodes)

$ cd ...fabric-samples/first-network

cli: used to join peers to channel
     deploy and instantiate chaincode
     drive execution of transactions against deployed chaincode

-------------------------------------------------------------------------------------------------------------------------------------
$  byfn.sh generate  # generate certificates, genesis  block, channel(+anchored peers)
           ^^^^^^^^
-------------------------------|-------------------------------------------|-------------------------------------------
generate network artifacts     | input net.topology(orgs, components)      | generated output (.../crypto-config)
cryptogen generate \           | crypto-config.yaml                        | x509 keys/certificates:
 --config=./crypto-config.yaml | --------------------------------------    | org1/2 root ca-certs
                               | ordererorgs:                              | /crypto-config
                               | - name: oºordererº                           |   /oºordererorganizationsº
                               |   domain: oºexample.comº                     |     /bºexample.comº
                               |   ca:                                     |      /msp
                               |       country: us                         |       /(tlscacerts|admincerts|cacerts)/
                               |       province: california                |      /users/(admin|user1|...)@"example.com"
                               |       locality: san francisco             |       /msp/...
                               |   specs:                                  |      /orderers/orderer."dom"/
                               |     - hostname: oºordererº                   |       (/msp/...,/tls/...)
                               | - name: org1                              |      /tlsca/...
                               |   domain: org1.example.com                |      /ca/...
                               |   enablenodeous: true                     |   /oºpeerorganizationsº
                               |   ...                                     |     /bºorg1.comº
                               | oºorderer.example.comº will                  |      /msp/...
                               | be tied to msp id of oºordererº              |      /peers/(peer0|peer1|admin|user1!...)@.bºorg1.comº
                               |                                           |        (/msp/...,/tls/...)
                               |                                           |      /tlsca/...
                               |                                           |      /ca/...
                               |                                           |     /bºorg2.comº
-------------------------------|-------------------------------------------|-------------------------------------------
configtxgen :                  | configtx.yaml contains definitions for:   |  generates orderer and channel gºartifactsº
                               |   - orderer org (ordererorg)              |  - orderer oºconfigurationº gº./channel-artifacts/genesis.blockº
 # fabric_cfg_path tells       |   - member org1 + msp directory location  |  - channel oºconfigurationº gº./channel-artifacts/channel.txº
 # configtxgen location of     |   - member org2 + msp directory location  |   - anchor peers transactions          gº./channel-artifacts/org1mspanchors.txº
 # configtx.yaml               |   - sampleconsortium (org1 + org2)        |                                        gº./channel-artifacts/org2mspanchors.txº
 export fabric_cfg_path=$pwd   |     note: consortia exist within the network scope
                               |       (sampleconsortium defined    in ºsystem-level  profileº)
# 1. order genesis block       |       channels  exist within the consortium scope
 ../bin/configtxgen \          |       (sampleconsortium referenced by ºchannel-level profileº)
   -profile twoorgsorderergenesis  - anchor peer0.org1.example.com         |
   -outputblock \              |   - anchor peer0.org2.example.com         |
   ./channel-artifacts/genesis.block                                       |
                               |  ---------------------                    |
# 2. channel tx                |                                           |
 ../bin/configtxgen            |  - "profiles"                             |
   -profile twoorgschannel     |
   -outputcreatechanneltx      |
   ./channel-artifacts/channel.tx ---------------------                    |
   -channelid $channel_name    |  (anchor peers for each peer org)         |
                               |
# 3. peer tx update            |
../bin/configtxgen             |
  -profile twoorgschannel      |
  -outputanchorpeersupdate     |
   ./channel-artifacts/org1mspanchors.tx
  -channelid $channel_name     |
  -asorg org1msp               |
-----------------------------------------------------------

<span xsmall>ºstarting the networkº</span>
(orderer and peers will stand by waiting for client requests)
the genesis.block must be present indicating the initial configuration
(consensus, block-size, ...) used by the blockchain network
channel_name=$channel_name \
timeout="pick_a_value" \
docker-compose -f docker-compose-cli.yaml up -d

<span xsmall>create channel</span>
# enter cli container (cli defined in docker-compose-cli.yaml)
# crypto_dir="/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/"
# orderer_host="orderer.example.com:7050"
$ docker exec -it cli bash  \
-e channel_name=mychannel \
-e orderer_root_cert="${crypto_dir}/ordererorganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem"

root@0d...:../peer# oºpeer channel createº \
    -o $orderer_host \
    -c $channel_name
    -f gº./channel-artifacts/channel.txº \
    --tls $core_peer_tls_enabled
    --cafile ${orderer_root_cert} # used for tls handshake
(returns genesis block - channel-id.block - which we will use to join the channel).
it contains the configuration information specified in channel.tx.

<span xsmall>ºjoin peer to the channelº</span>
root@0d.../peer# oºpeer channel joinº -b ˂channel-id.block˃
(join other peers join by making appropriate changes in envvars)


<span xsmall>ºinstall and instantiate chaincodeº</span>
  - we need to install the chaincode on every peer that will
    execute and endorse our transactions, and then instantiate
    the chaincode on the channel.
  - install (sample go code) onto one of the four peer nodes.
    next command places the <e>source code</e> onto our peer's filesystem:

.../peer# git_repo="github.com/hyperledger/fabric"
.../peer# git_repo="${git_repo}/examples/chaincode"
.../peer# git_repo="${git_repo}/go/chaincode_example02"
.../peer# peer chaincode install \
                 -n mycc -v 1.0 -p ${git_repo}

  - instantiate chaincode on the channel,
    set endorsement policy for the chaincode,
    and launch a chaincode container for the targeted peer.
root@0d.../peer# peer chaincode \
    instantiate \
    -o orderer.example.com:7050 \
    --tls $core_peer_tls_enabled \
    --cafile ${ca_f} \
    -c $channel_name \
    -n mycc -v 1.0 \
    -c '{"args":["init","a", "100", "b","200"]}' \
    -p "or ('org1msp.member','org2msp.member')"

# note: -(p)olicy: <a href="http://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html">required endorsement level</a>
#                 for tx against this chaincode

<span xsmall>ºquery and invoqueº</span>
  - query for the value of a to make sure the chaincode was properly instantiated and the state db was populated.
root@0d.../peer# peer chaincode query \
          -c $channel_name -n mycc \
          -c '{"args":["query","a"]}'
<span xsmall>create a tx (proposal)</span>
- let’s move 10 from a to b:
root@0d.../peer# peer chaincode invoke \
    -o orderer.example.com:7050  \
    --tls $core_peer_tls_enabled \
    --cafile ${ca_f} \
    -c $channel_name -n mycc \
    -c '{"args":["invoke","a","b","10"]}'
</pre>

<pre zoom labels="chaincode,example">
<span xsmall>fabcar.go chaincode example</span>
@[https://github.com/hyperledger/fabric-samples/blob/release/chaincode/fabcar/fabcar.go]
RºWARNº: summary error checks removed. Never do that in real blockchain projects.
// structures
type car struct {                   type smartcontract struct { }
    make   string `json:"make"`
    model  string `json:"model"`
    colour string `json:"colour"`
    owner  string `json:"owner"`
}

func (s *smartcontract) initledger(
       apistub shim.chaincodestubinterface) sc.response {
    cars := []car{ // ledger initialization outside init
        car{ make: "toyota", model: "prius", colour: "blue", owner: "tomoko"},
        car{make: "ford", model: "mustang", colour: "red", owner: "brad"},
        ...  }

    i := 0 ; for i ˂ len(cars) {
        carasbytes, _ := json.marshal(cars[i])
        apistub.putstate("car"+strconv.itoa(i), carasbytes)
        fmt.println("added", cars[i])
        i = i + 1
    }
    return shim.success(nil)
}

// called when instantiated by the blockchain network
func (s *smartcontract) init(apistub shim.chaincodestubinterface) sc.response {
    return shim.success(nil)
}

/* called as a result of application request to
   run the smart contract "fabcar" */
func (s *smartcontract) invoke( apistub shim.chaincodestubinterface) sc.response {
    // retrieve the requested smart contract func.+args.
    function, args := apistub.getfunctionandparameters()
    if function == "querycar" {
        return s.querycar(apistub, args)
    } else if function == "initledger" {
        return s.initledger(apistub)
    } else if function == "createcar" {
        return s.createcar(apistub, args)
    } else if function == "queryallcars" {
        return s.queryallcars(apistub)
    } else if function == "changecarowner" {
        return s.changecarowner(apistub, args)
    }
}

func (s *smartcontract) querycar( apistub shim.chaincodestubinterface, args []string) sc.response {
    carasbytes, _ := apistub.getstate(args[0])
    return shim.success(carasbytes)
}

func (s *smartcontract) createcar( apistub shim.chaincodestubinterface, args []string) sc.response {
    var car = car{make: args[1], model: args[2],
                  colour: args[3], owner: args[4]}
    carasbytes, _ := json.marshal(car)
    apistub.putstate(args[0], carasbytes)
    return shim.success(nil)
}

func (s *smartcontract) queryallcars( apistub shim.chaincodestubinterface) sc.response {
    startkey := "car0"
    endkey := "car999"
    resultsiterator, err :=
       apistub.getstatebyrange(startkey, endkey)
    defer resultsiterator.close()

    var buffer /* json array */ bytes.buffer
    buffer.writestring("[")
    for resultsiterator.hasnext() {
        queryresponse, err := resultsiterator.next()
        ...
        buffer.writestring("{\"key\":")
        buffer.writestring("\"")
        ...
    }
    ...
    return shim.success(buffer.bytes())
}

func (s *smartcontract) changecarowner( apistub shim.chaincodestubinterface, args []string) sc.response {
    carasbytes, _ := apistub.getstate(args[0])
    car := car{}
    json.unmarshal(carasbytes, ⅋car)
    car.owner = args[1]
    carasbytes, _ = json.marshal(car)
    apistub.putstate(args[0], carasbytes)
    return shim.success(nil)
}

func main /* testing purposes*/() {
    // create new contract
    err := shim.start(new(smartcontract))
}
</pre>

<pre zoom labels="chaincode,example">
<a xsmall href='https://github.com/hyperledger/fabric-samples/blob/release/fabcar/query.js'>fabcar query.js</a>
(errors and async code removed)
var hfc = require('fabric-client');
var path = require('path');
var options = {
    wallet_path: path.join(__dirname, './creds'),
    user_id: 'peeradmin',
    channel_id: 'mychannel',
    chaincode_id: 'fabcar',
    network_url: 'grpc://localhost:7051',
};

var client = new hfc(); // create client
wallet = hfc.newdefaultkeyvaluestore(
    { path: options.wallet_path });
client.setstatestore(wallet); // set wallet path
// associate user to app
user = client.getusercontext(options.user_id, true);
var channel = client.newchannel(options.channel_id);
channel.addpeer(client.newpeer(options.network_url));
// make query
var transaction_id = client.newtransactionid();
const request = {
  chaincodeid: options.chaincode_id,
  txid: transaction_id,
  fcn: 'queryallcars', args: [''] };
query_responses = channel.querybychaincode(request);
// console.log("count = ", query_responses.length)
if (query_responses[0] instanceof error) {
  console.error("error from query = ", query_responses[0]);
}
console.log("response: ", query_responses[0].tostring());
</pre>

<pre zoom labels="chaincode,example">
  <a xsmall href='https://github.com/hyperledger/fabric-samples/blob/release/fabcar/invoke.js'>fabcar invoke.js</a>
(errors removed)
var hfc = require('fabric-client');
var path = require('path');
var util = require('util');

var options = {
    wallet_path: path.join(__dirname, './creds'),
    user_id: 'peeradmin',
    channel_id: 'mychannel',
    chaincode_id: 'fabcar',
    peer_url: 'grpc://localhost:7051',
    event_url: 'grpc://localhost:7053',
    orderer_url: 'grpc://localhost:7050'
};

var client = null;
var targets = [];
console.log("create a client and set the wallet location");
client = new hfc();
var wallet = hfc.newdefaultkeyvaluestore({ path: options.wallet_path });
console.log("set wallet path, and associate user ",
          options.user_id, " with application");
client.setstatestore(wallet);
var user = client.getusercontext(options.user_id, true);
console.log("check user is enrolled, and set a query url
         in the network");
var channel = client.newchannel(options.channel_id);
var peerobj = client.newpeer(options.peer_url);
channel.addpeer(peerobj);
channel.addorderer(client.neworderer(options.orderer_url));
targets.push(peerobj);
var tx_id = client.newtransactionid();
console.log("assigning transaction_id: ", tx_id._transaction_id);
// createcar - requires 5 args, ex: args:
// ['car11', 'honda', 'accord', 'black', 'tom'],
// changecarowner - requires 2 args , ex: args: ['car10', 'barry'],
// send proposal to endorser
var request = {
    targets: targets,
    chaincodeid: options.chaincode_id,
    fcn: 'createcar',
    args: ['car10', 'chevy', 'volt', 'red', 'nick'],
    chainid: options.channel_id,
    txid: tx_id
};
var results = channel.sendtransactionproposal(request);
var proposalresponses = results[0];
var proposal = results[1];
var header = results[2];
let isproposalgood = false;
console.log(util.format(
    'successfully sent proposal and received'
  + ' proposalresponse: status - %s, message - "%s",'
  + ' metadata - "%s",'
  + ' endorsement signature: %s',
    proposalresponses[0].response.status,
    proposalresponses[0].response.message,
    proposalresponses[0].response.payload,
    proposalresponses[0].endorsement.signature));
var request = {
    proposalresponses: proposalresponses,
    proposal: proposal,
    header: header
};
// set the transaction listener and 30sec timeout
// if the tx did not get committed within timeout
// fail the test
var transactionid = tx_id.gettransactionid();
var eventpromises = [];
let eh = client.neweventhub();
eh.setpeeraddr(options.event_url);
eh.connect();

let txpromise = new promise((resolve, reject) =˃
{
  let handle = settimeout(() =˃ {
    eh.disconnect(); reject(); }, 30000);
  eh.registertxevent(transactionid, (tx, code) =˃ {
    cleartimeout(handle);
    eh.unregistertxevent(transactionid);
    eh.disconnect();
    if (code === 'valid') {
        console.log(
            'tx has been committed on peer ' +
            eh._ep._endpoint.addr);
        resolve();
    }
  });
});
eventpromises.push(txpromise);
var sendpromise = channel.sendtransaction(request);
var results = sendpromise.concat(eventpromises))
    console.log('event promise all '
    + ' complete and testing complete');
var response = results[0]; // 1st returned value is from
                   // 'sendpromise' which is from
                   // 'sendtransaction()' call
if (response.status === 'success') {
    console.log('successfully sent tx to orderer.');
    return tx_id.gettransactionid();
}
</pre>
</div>

<div groupv>
<pre zoom labels="TODO">
<span xsmall>VS Code Fabric plugin</span>
@[https://marketplace.visualstudio.com/items?itemName=IBMBlockchain.ibm-blockchain-platform]
End to end extension for Hyperledger Fabric developers. Develop and 
test your blockchain smart contracts and client applications on your 
local machine, and package your projects for deployment into IBM 
Blockchain Platform runtimes.
</pre>

<span title>client sdks</span>
<pre zoom labels="client,nodejs">
<span xsmall>nodejs sdk</span>                    |
@[https://fabric-sdk-node.github.io/] available to:
- create <a href="http://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#privacy-through-channels">channels</a>
- ask <a href="http://hyperledger-fabric.readthedocs.io/en/latest/arch-deep-dive.html#peer">peer nodes</a> to join the channel
- install <a href="http://hyperledger-fabric.readthedocs.io/en/latest/fabric_model.html#chaincode">chaincodes</a> in peers using the consensus process (can be preinstalled in setup scripts)
- instantiate chaincodes in a channel
- invoke transactions by calling the chaincode
- query the ledger for transactions or blocks
- receive ledger updates
- apis are split between two npm modules:
  - composer-client:
    - submits txs to a network, crud opts on assets and participants
    - installed as local dependency for app.
    - when in production this is only module that needs to be added
      as a direct dependency of the application.
  - composer-admin:
    - manages business networks (creation/deploy, undeploy)
    - installed as a local dependency of admin. apps
</pre>

<pre zoom labels="client,java">
<span xsmall>java sdk</span>
@[https://github.com/hyperledger/fabric-sdk-java]
@[https://fabric-chaincode-java.github.io/]
- manage the lifecycle of hyperledger channels and user chaincode
- execute user chaincode, query channel blocks and txs
- <a href="https://github.com/hyperledger/fabric-sdk-java/blob/master/src/test/java/org/hyperledger/fabric/sdkintegration/end2endit.java">end2endit</a> provide a "full-journey" example installing, instantiating, invoking and querying a chaincode.
- <a href="https://github.com/hyperledger/fabric-sdk-java/blob/master/src/test/java/org/hyperledger/fabric/sdkintegration/end2endandbackagainit.java">end2endandbackagainit.java</a> shows recreating the channel objects created in end2endit.java and upgrading chaincode and invoking the up graded chaincode
- monitor events on the channel
- channels may be serialized via java serialization in the context of a client
- channels deserialized are not in an initialized state. applications need to handle migration of serialized files between versions
- hyperledger's certificate authority client
˂dependency˃
    ˂groupid˃org.hyperledger.fabric-sdk-java˂/groupid˃
    ˂artifactid˃fabric-sdk-java˂/artifactid˃
    ˂version˃1.1.0˂/version˃
˂/dependency˃
- chaincode endorsement policies
  - policies are described in the <a href="https://gerrit.hyperledger.org/r/gitweb?p=fabric.git;a=blob;f=docs/endorsement-policies.md;h=1eecf359c12c3f7c1ddc63759a0b5f3141b07f13;hb=head">fabric endorsement policies</a> document.
  - you create a policy using a fabric tool ( an example is shown in
<aref="https://jira.hyperledger.org/browse/fab-2376?focusedcommentid=21121&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-21121">jira issue fab-2378</a>)
  d give it to the sdk either as a file or a byte array. the sdk, in turn, will use the policy when it creates chaincode instantiation requests.
  - to input a policy to the sdk, use the chaincodeendorsementpolicy class.
  - for testing purposes, there are 2 policy files in the src/test/resources directory
    policybitsadmin ( which has policy and(default.admin) meaning 1 signature from the default msp admin' is required )
    policybitsmember ( which has policy and(default.member) meaning 1 signature from a member of the default msp is required )
    and one file in the src/test/fixture/sdkintegration/e2e-2orgs/channel directory specifically for use in the end to end test scenario
    members_from_org1_or_2.policy ( which has policy or(peerorg1.member, peerorg2.member) meaning 1 signature from a member of either organizations peerorg1, peerorg2 is required)
      alternatively, you can also use chaincodeendorsementpolicy class by giving it a yaml file
      that has the policy defined in it. see examples of this in the end2endit testcases that use
      src/test/fixture/sdkintegration/chaincodeendorsementpolicy.yaml the file chaincodeendorsementpolicy.yaml
      has comments that help understand how to create these policies. the first section lists all the signature
      identities you can use in the policy. currently, only role types are supported. the policy section
      is comprised of n-of and signed-by elements. then n-of (1-of 2-of) require that many (n) in that section
      to be true. the signed-by references an identity in the identities section.

- channel creation artifacts
  - channel configuration files and orderer bootstrap files ( see directory
    src/test/fixture/sdkintegration/e2e-2orgs ) are needed when creating a new channel.
    this is created with the hyperledger fabric configtxgen tool. this must be run after
    cryptogen and the directory you're running in must have a generated crypto-config
    directory.
    (if build/bin/configtxgen tool is not present run make configtxgen)
  - for v1.0 integration test the commands are:
     $ build/bin/configtxgen -outputcreatechanneltx foo.tx -profile twoorgschannel -channelid foo
     $ build/bin/configtxgen -outputcreatechanneltx bar.tx -profile twoorgschannel -channelid bar
    for v1.1 integration the commands use the v11 profiles in configtx.yaml. you need to for now copy
    the configtx.yaml in e2e-20orgs to the v1.1 directory and run from there:
      $ configtxgen -outputblock orderer.block -profile twoorgsorderergenesis_v11
      $ configtxgen -outputcreatechanneltx bar.tx -profile twoorgschannel_v11 -channelid bar
      $ configtxgen -outputcreatechanneltx foo.tx -profile twoorgschannel_v11 -channelid foo
(this should produce in the v1.1 directory: bar.tx,foo.tx, orderer.block)
     note: the above describes how this was done. if you redo this there are private key files which
     are produced with unique names which won't match what's expected in the integration tests.
     one examle of this is the docker-compose.yaml (search for _sk)

- go lang chaincode dependencies must be contained in vendor folder.
- (see also  basic troubleshooting section)
</pre>
</div>

<div groupv>
<span title>devops</span>
<pre zoom labels="101,devops"  bgorange>
<span xsmall>cli reference</span>
- @[https://hyperledger-fabric.readthedocs.io/en/latest/command_ref.html]
- peer (admin command)    @[https://hyperledger-fabric.readthedocs.io/en/latest/commands/peercommand.html]
                          @[https://github.com/hyperledger/fabric/blob/release-2.0/core/peer/peer.go]
  -ºpeer chaincode        º @[https://hyperledger-fabric.readthedocs.io/en/latest/commands/peerchaincode.html]
  -ºpeer channel          º @[https://hyperledger-fabric.readthedocs.io/en/latest/commands/peerchannel.html]

    ex: fetch channel config as org1-admin:
    export next variables:
    core_peer_localmspid="org1msp"
    core_peer_tls_rootcert_file=${org1}/peers/peer0.org1.ex.com/tls/ca.crt # ← tls used for gossip/discovery net.protocol
        core_peer_mspconfigpath=${org1}/users/admin@org1.ex.com/msp
    core_peer_address=peer0.org1.ex.com:7051

    $ peer channel fetch config \
      config_block.pb \
      -c $channel_name \
      -o orderer.ex.com:7050 --tls --cafile $orderer_ca
     ...
     2017-11-07 17:17:57.383 utc [channelcmd] readblock ... received block: 2
  
  -ºpeer version          º @[https://hyperledger-fabric.readthedocs.io/en/latest/commands/peerversion.html]
  -ºpeer node             º @[https://hyperledger-fabric.readthedocs.io/en/latest/commands/peernode.html]
  -ºpeer lifecycle chainc.º @[https://hyperledger-fabric.readthedocs.io/en/latest/commands/peerlifecycle.html]

-ºconfigtxgenº(user)      @[https://hyperledger-fabric.readthedocs.io/en/latest/commands/configtxgen.html]
  create and inspect channel config related artifacts.
  the content of the generated artifacts is dictated
  by ofºconfigtx.yamº.

-ºconfigtxlator(user)  º  @[https://hyperledger-fabric.readthedocs.io/en/latest/commands/configtxlator.html]
  translate between protobuf and json versions of fabric data structures and 
  create config updates. the command may either start a rest server to expose its 
  functions over http or may be utilized directly as a command line tool.

-ºcryptogen(admin)     º  @[https://hyperledger-fabric.readthedocs.io/en/latest/commands/cryptogen.html]
  utility for generating key material forºpreconfiguringºa network
 ºfor testing purposesº (normally not be used in production network)

-ºservice discovery cliº  @[https://hyperledger-fabric.readthedocs.io/en/latest/discovery-cli.html]
  - yaml used to persist properties (certs, priv.key paths, msp.ids,...)
  - subcommands:
    - saveconfig
    - peers
    - config
    - endorsers

- fabric-ca commands      @[https://hyperledger-fabric.readthedocs.io/en/latest/commands/fabric-ca-commands.html]
  -ºfabric-ca-clientº: @[https://hyperledger-fabric-ca.readthedocs.io/en/release-1.4/clientcli.html#fabric-ca-client-s-cli]
    - manage identities (attributes,...) and certificates (renewal,revocation).
  -ºfabric-ca-serverº: @[https://hyperledger-fabric-ca.readthedocs.io/en/release-1.4/servercli.html#fabric-ca-server-s-cli]
    - initialize/start server process hosting certificate authority.
</pre>
<pre zoom labels="101,devops,docker">
<span title>install</span>
<span xsmall>prerequisites</span>
- @[https://hyperledger-fabric.readthedocs.io/en/latest/prereqs.html]
- @[https://docs.docker.com/engine/installation/linux/docker-ce/centos/#prerequisites]
  dependencies: curl, git,
         docker 17.06.02-ce+ (2017-09-05)(docker engine 1.13.x not supported),
         <a href='https://go-repo.io/'>adding docker-ce repo to yum</a>
         docker-compose 1.14.0+ see <a href='https://docs.docker.com/compose/install/#install-compose'>here</a> to install latest version

- go programming language 1.9.x
    check $gopath="working directory" (example $home/go)
    <a href='https://go-repo.io/'>install custom golang repo</a>

- node.js 6.9.x runtime (7.x not yet supported) and npm (npm install npm@3.10.10 -g)
- python 2.7 (sudo apt-get install python)
<span xsmall>prebuilt docker images</span>
base:                          tcp
                               ports
  hyperledger/fabric-peer      7050(orderer) ← (linux ps) 
  hyperledger/fabric-orderer   7051(peer)    ← (linux ps) $ <a href="https://github.com/hyperledger/fabric/blob/release-1.1/...">orderer</a>
                               7053(peer_event)
                               6060(???)
  hyperledger/fabric-ccenv           fabric chaincode container/environment
  hyperledger/fabric-ca        7054(ca) default fabric ca (linux ps) $ fabric-ca-server start --ca.certfile /etc/... --ca.keyfile /etc/... -b admin:adminpw -d
  hyperledger/fabric-javaenv         fabric java chaincode environment
  hyperledger/fabric-tools           "command line shell"
                                     it must mount volumes in a way similar to:
                                     /var/run/          :/host/var/run/
                                     ./../chaincode/    :/opt/gopath/src/github.com/chaincode
    x.509 generated by 'cryptogen' → ./crypto-config    :/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/
                                     ./scripts          :/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/
   orderer genesis.block (config), → ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts
        channel tx, anchorpeer txs
        generated by 'configtxgen'

extra:
  hyperledger/fabric-membersrvc ???? fabric member service docker image
  hyperledger/fabric-couchdb    5984(couchdb) fabric couchdb docker image
  hyperledger/fabric-kafka           fabric kafka docker image
  hyperledger/fabric-zookeeper       fabric zookeeper docker image

dev:
  hyperledger/fabric-baseimage       base image for https://gerrit.hyperledger.or…
  hyperledger/fabric-baseos          fabric base os
</pre>
<pre zoom labels="101,devops,">
<span xsmall>env.vars</span>
core_peer_gossip_useleaderelection=true
core_peer_gossip_orgleader=false
core_peer_profile_enabled=true
core_peer_id=peer0.exporterorg.trade.com
core_peer_address=peer0.exporterorg.trade.com:7051
core_peer_gossip_bootstrap=peer0.exporterorg.trade.com:7051
core_peer_gossip_externalendpoint=peer0.exporterorg.trade.com:7051
core_peer_localmspid=exporterorgmsp


orderer_general_loglevel=info
orderer_general_listenaddress=0.0.0.0
orderer_general_genesismethod=file
orderer_general_genesisfile=/var/hyperledger/orderer/orderer.genesis.block
orderer_general_localmspid=tradeorderermsp
orderer_general_localmspdir=/var/hyperledger/orderer/msp

fabric_ca_home=/etc/hyperledger/fabric-ca-server
fabric_ca_server_ca_name=ca-exporterorg


# tls related
       core_peer_tls_enabled=true
 orderer_general_tls_enabled=true
fabric_ca_server_tls_enabled=true

        core_peer_tls_key_file=/etc/.../server.key
  fabric_ca_server_tls_keyfile=/etc/.../355f8e6...cb_sk
orderer_general_tls_privatekey=/var/hyperledger/orderer/tls/server.key

core_peer_tls_rootcert_file=/etc/hyperledger/fabric/tls/ca.crt
orderer_general_tls_rootcas=[/var/hyperledger/orderer/tls/ca.crt]

  fabric_ca_server_tls_certfile=/etc/...
orderer_general_tls_certificate=/var/hyperledger/orderer/tls/server.crt
        core_peer_tls_cert_file=/etc/.../server.crt
</pre>
<pre bgorange zoom labels="101,devops,">
<span xsmall>(dockerized) minimum deployment</span>
- dev.mode
@[https://github.com/hyperledger/fabric-samples/tree/release-1.1/chaincode-docker-devmode]
┌─────────────────────────────────────────────────┐ ┌─────────────────────────────────────────────────┐  docker-compose-cli.yaml *1
│orderer: ports: 7050:7050                        │ │peer: ports: 7051 7053 6060                      │  ...
├─────────────────────────────────────────────────┤ ├─────────────────────────────────────────────────┤  services:
│image: hyperledger/fabric─orderer                │ │image: hyperledger/fabric─peer                   │    orderer.${domain}:
│orderer_general_loglevel=debug                   │ │core_peer_id=peer                                │      container_name: orderer.${domain}
│orderer_general_listenaddress=orderer            │ │core_peer_address=peer:7051                      │      extends:
│orderer_general_genesismethod=file               │ │core_peer_gossip_externalendpoint=peer:7051      │        file:   base/docker-compose-base.yaml
│orderer_general_genesisfile=orderer.block        │ │core_peer_localmspid=default                     │        service: orderer.${domain}
│orderer_general_localmspid=default               │ │core_vm_endpoint=unix:///host/var/run/docker.sock│  ...
│orderer_general_localmspdir=/etc/hyperledger/msp │ │core_logging_level=debug                         │    peer0.${org1}.${domain}:
│command: orderer                                 │ │core_peer_mspconfigpath=/etc/hyperledger/msp     │    (same for  peer1.${org1}.${domain})
│                                                 │ │command: peer node start \                       │    (same for  peer0.${org2}.${domain})
│                                                 │ │    ──peer─chaincodedev=true ─o orderer:7050     │      container_name: peer0.${org1}.${domain}
│                                                 │ │depends─on: orderer                              │      extends:
└─────────────────────────────────────────────────┘ └─────────────────────────────────────────────────┘        file:  base/docker-compose-base.yaml
                                                                                                               service: peer0.${org1}.${domain}
┌─────────────────────────────────────────────────┐ ┌─────────────────────────────────────────────────┐  
│chaincode:                                       │ │cli:                                             │    cli:
├─────────────────────────────────────────────────┤ ├─────────────────────────────────────────────────┤      container_name: cli
│image: hyperledger/fabric─ccenv                  │ │image: hyperledger/fabric─tools                  │      image: hyperledger/fabric-tools
│gopath=/opt/gopath                               │ │gopath=/opt/gopath                               │      tty: true
│core_vm_endpoint=unix:///host/var/run/docker.sock│ │core_vm_endpoint=unix:///host/var/run/docker.sock│      ...
│core_logging_level=debug                         │ │core_logging_level=debug                         │      volumes:
│core_peer_id=example02                           │ │core_peer_id=cli                                 │          ...
│core_peer_address=peer:7051                      │ │core_peer_address=peer:7051                      │          - ./crypto-config     :.../peer/crypto/
│core_peer_localmspid=default                     │ │core_peer_localmspid=default                     │          - ./channel-artifacts :.../channel-artifacts
│core_peer_mspconfigpath=/etc/hyperledger/msp     │ │core_peer_mspconfigpath=/etc/hyperledger/msp     │      depends_on:
│command: /bin/bash ─c 'sleep 6000000'            │ │command: /bin/bash ─c './script.sh'              │        - orderer.${domain}
│                                                 │ │depends─on: orderer, peer                        │        - peer0.${org1}.${domain}
│depends─on: orderer, peer                        │ └─────────────────────────────────────────────────┘        - ...
└─────────────────────────────────────────────────┘
*1 @[https://github.com/hyperledger/fabric-samples/blob/release/first-network/docker-compose-cli.yaml]
</pre>
</div>

<div groupv>
<span title>release notes</span>
<pre zoom labels="todo">
@[https://github.com/hyperledger/fabric/releases]
<span title>v2.0.0 2020-01-29</span>

ºmajor featuresº:
- Decentralized smart contract governance:
  new process for installing/starting a chaincode on peers
  allowing multiple organizations to come to agreement 
  on parameters before it can be used to interact
  with the ledger.

- new patterns for working with and sharing private data,
  - share private data across collections,
    where each collection may include a single organization,
    or perhaps a single organization along with a regulator or auditor.

- External chaincode launcher: Allows DevOps to build and launch
  chaincode with the technology of their choice. (not just Docker)

ºImportant Changesº
- The ccenv build image no longer includes the shim
- Logger (NewLogger()) removed from chaincode shim
  Chaincode is intended to be the responsibility of app developer now.
- go chaincode entities extension has been removed
- GetHistoryForKey returns results from newest to oldest
  In prior releases, this API had no guarantees on the
  order of returned results.
- System Chaincode Plugins have been removed.
 ºgeneral move away from go-plugins as extension mechanismº

-ºDocker based images with Alpine Linuxº
  security-oriented, lightweight Linux distribution.
  - WARN: Bash not available 
- Chaincode images are now built upon installation on peer
  (vs at instantiation time as in prior releases).
  Expect chaincode installation to take longer than
  in prior releases.

- Policies must be specified in configtx.yaml
  (no default policies exists now) 

-ºWarn when certificates are about to expire a week before.º

ºDeprecationsº
- 'Solo' consensus type is deprecated.
- 'Kafka' consensus type is deprecated in favor of 'Raft'
- ...

ºKnown Issues and Workaroundsº
- Same chaincode source receiving fingerprint mismatch error
- Peer should detect and react when its org has been removed

<span title>v1.4.4 2019-06-09</span>
ºnew featuresº
- Fabric operations service
A new HTTP based "operations" endpoint has been implemented on the orderer and
the peer. The endpoint exposes APIs to check the server's health, to query
and modify the logging level of the process, and, when configured, to expose
Fabric metrics.

-ºOperational metrics for Fabric componentsº
  for consumption by Prometheus or StatsD.

-ºHealth check endpointº
   The orderer and the peer now provide a mechanism to check the health of the
   process via an HTTP request. Requests to GET /healthz on the operations
   endpoint will complete with a status 200 OK when the server believes it is
   healthy. When a health check fails, the server will respond with a 503 Service
   Unavailable and a JSON payload indicating which component detected an issue.
   The types of health checks that are performed will be extended over time.

- Dynamic log levels

- FAB-5093 - Private data reconciliation
Allows peers for organizations that are added to private data collections
to retrieve the private data for prior transactions to which they now are
entitled. 

- FAB-11409 - Private data client access control
Ability to automatically enforce access control within chaincode based
on the client organization collection membership without having to
write specific chaincode logic. This feature is configured by using
the collection configuration property memberOnlyRead:true. If you have
a mixed network of v1.4 peers and prior release peers, the prior
release peers will not honor this configuration until they are upgraded
to v1.4.
</pre>
</div>

<div groupv>
<span title>un-ordered notes</span>
<pre zoom labels="todo">
<span xsmall>cross-chaincode txs</span>
- post-v1 feature
</pre>



<pre zoom labels="devops,db_engine,todo">
<span xsmall>couchdb configuration</span>
@[https://hyperledger-fabric.readthedocs.io/en/latest/ledger.html]
</pre>
</div>
<div groupv>
<span title>understanding code base</span>
<pre zoom labels="codebase,">
<span xsmall>core</span>
@[https://github.com/hyperledger/fabric/tree/master/core]
@[https://github.com/hyperledger/fabric/tree/release-2.0/core]
</pre>
<pre zoom labels="devops,monitoring">
<span xsmall>/healthz</span>
Fabric 1.4:
-ºHealth check endpointº
  The orderer and the peer now provide a mechanism to check the health of the
  process via an HTTP request. Requests to GET /healthz on the operations
  endpoint will complete with a status 200 OK when the server believes it is
  healthy. When a health check fails, the server will respond with a 503 Service
  Unavailable and a JSON payload indicating which component detected an issue.
  The types of health checks that are performed will be extended over time.
</pre>

<pre zoom labels="devops,monitoring">
<span xsmall>dynamic log levels</span>
In earlier versions of Fabric (˂1.4), loggers were associated with named components
and configuration would control the active level of each logger. While this
model works in theory, because of the configuration management libraries used
by Fabric and the structure of the Fabric code base, in practice it had a
number of issues.
With 1.4, we're changing the model slightly. Instead of associating loggers
with components, we are naming loggers and to help avoid side effects during
initialization, the logging configuration is no longer obtained from the
fabric configuration system but from environment variables that define
the logging specification and log format.
  The log specification is a single string that consists of colon separated
tokens. Each token declares one or more logger name prefixes (separated by
commas) and an optional log level. When the logger name prefix ends with a
period, it indicates that the log level should only apply to the logger with
that exact name without the trailing period. When the logger name pattern is
omitted, it specifies the default log level. In cases where multiple entries
reference the same name pattern or multiple instances of a default are
provided, the last specification takes precedence.
</pre>
<pre zoom labels="">
<span xsmall>Dump Go Routine Stack</span>
1.4+ FAB-12372 - Obtain Go routine stacks without termination
When SIGUSR1 is received by the peer or the orderer, the state of all go
routines will be captured and logged at the INFO level. This collection
activity will not terminate the process.
</pre>




    
</div>
</body>
</html>
<!--
cryptographic hash of tx is used by all nodes as a unique
transaction identifier tid=hash(tx)). the client
stores tid in memory and waits for responses from endorsing peers.
________________________________

DevOps: fabric on AKS: 
https://docs.microsoft.com/en-us/azure/blockchain/templates/hyperledger-fabric-consortium-azure-kubernetes-service
it is a good practice to model chaincode asset data as json, so that you have
the option to perform complex rich queries if needed in the future.
____________________________________
during chaincode instantiation ($ peer chaincode instantiate ...) if the identity classification is enabled
(see membership service providers (msp)), one can use the peer role to restrict endorsement to only peers.
____________________________
https://hyperledger-fabric.readthedocs.io/en/latest/error-handling.html
____________________________
https://hyperledger-fabric.readthedocs.io/en/latest/logging-control.html
____________________________
https://hyperledger-fabric.readthedocs.io/en/latest/enable_tls.html
____________________________________
https://hyperledger-fabric.readthedocs.io/en/latest/idemixgen.html
_____________________________________
<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.1/architecture.html">architecture</a>
_____________________________________
todo:(0) <a href="http://hyperledger-fabric.readthedocs.io/en/latest/commands/configtxgen.html">configtxgen</a>
_____________________________________
capabilities (v1.1+, defined in config.tx) define features which must be
present in a fabric binary for that binary to safely participate in the
fabric network. (todo: added to x.509 certs?).
capabilities apply to both orderers and peers and must be supported by both.
_____________________________________
you will have to install the composer playground in addition then the composer rest server during the lab.
_____________________________________
in an ideal trade scenario, only the process of preparing and shipping the goods would take time. recently, the adoption of swift messaging over manual communication has made the document application and collection processes more efficient, but it has not fundamentally changed the game. a blockchain, on the other hand, with its (almost) instantaneous transaction commitments and assurance guarantees, opens possibilities that did not previously exist.

as an example, the one variation we introduced in our use case was payment by installments, which cannot be implemented in the legacy framework because there is no guaranteed way of knowing and sharing information about a shipment's progress. such a variation would be deemed too risky in this case, which is why payments are linked purely to documentary evidence. by getting all participants in a trade agreement on a single blockchain implementing a common smart contract, we can provide a single shared source of truth that will minimize risk and simultaneously increase accountability

the criterion for the approval of a transaction (or invocation) is an endorsement policy (which we will revisit later in this chapter). it is framed in terms of the organizations that are participating in the application network, and not the peers themselves
_________________________________
https://github.com/hyperledgerhandson/
_________________________________
every chaincode must implement the chaincode interface, whose methods are called in response to the received transaction proposals. the chaincode interface defined in the shim package is shown in the following listing:
type chaincode interface {
     init(stub chaincodestubinterface) pb.response
     invoke(stub chaincodestubinterface) pb.response
}

 as you can see, the chaincode type defines two functions: init and invoke.both functions have a single argument, stub, of the type chaincodestubinterface.the stub
 argument is the main object that we will use when implementing the chaincode functionality, as it provides functions for accessing and modifying the ledger, obtaining invocation arguments, and so on.additionally, the shim package provides other types and functions in order to build chaincodes; you can inspect the whole package at: https://godoc.org/github.com/hyperledger/fabric/core/chaincode/shim.
_________________________

fabric ca issues enrollment certificates (ecerts) for network users.
  the ecert represents the identity of the user and is used as a signed
transaction when a user submits to fabric. prior to invoking a transaction,
the user must therefore first register and obtain an ecert from the fabric ca.
_________________________
attribute-based access control (abac):
can be used by the chaincode to control access to its functions and data. the
abac allows the chaincode to make access control decisions based on
attributes associated with user identity. users with an ecert can also access
a series of additional attributes (that is, name/value pairs).

in the following steps, we will show you how to register a user and create an
ecert with attributes. we will then retrieve the user identity and the
attributes in the chaincode to validate access control. we will then
integrate this functionality into our tutorial chaincode.first, we must
register a new user with the fabric ca. as part of the registration process,
we have to define the attributes that will be used once the ecert is generated
. a user is registered by running the command, fabric-ca-client register. the
access control attributes are added by using the suffix :ecert.
_________________________
plugable consensus include:
pbft, no-op, sieve, ... more
_________________________


_________________________
<a href="https://hyperledger-fabric.readthedocs.io/en/latest/kafka.html">bringing up a kafka-based ordering service</a>
identify steps needed to have a set of fabric ordering service nodes (osns) use kafka cluster providing an ordering service to the blockchain network</a>
- the abc of kafka on fabric: https://codeburst.io/the-abcs-of-kafka-in-hyperledger-fabric-81e6dc18da56
- https://github.com/hyperledger/fabric/blob/master/docs/source/kafka.rst
- https://cdn-images-1.medium.com/max/1600/1*lg29hswrrauvba8nojeata.png

_________________________
what's new 1.2:
https://hyperledger-fabric.readthedocs.io/en/release-1.2/whatsnew.html

<a  href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/private-data/private-data.html">private data collections</a>
a way to keep certain data/transactions confidential among a subset of channel
members. we also have an architecture document on this topic which can be found
<a  href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/private-data-arch.html">here</a>.</li>

<a  href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/discovery-overview.html">service discovery</a>
discover network services dynamically, including orderers, peers, chaincode, and endorsement policies, to simplify client applications.


<a  href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/access_control.html">access control</a>
how to configure which client identities can interact with peer functions on a per channel basis.

<a  href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/pluggable_endorsement_and_validation.html">pluggable endorsement and validation</a>:
utilize pluggable endorsement and validation logic per chaincode.


new-tutorials
<a  href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/upgrade_to_newest_version.html">upgrade to version v1.2</a>
leverages the byfn network to show how an upgrade flow should work. includes both a script (which can serve as a template for upgrades), as well as the individual commands

<a  href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/couchdb_tutorial.html">couchdb</a>
how to set up a couchdb data store (which allows for rich queries).

<a  href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/private_data_tutorial.html">private data</a>: shows how to set up a collection using byfn.
<a  href="https://hyperledger-fabric-ca.readthedocs.io/en/latest/users-guide.html#manage-certificates">query certificates based on various filter criteria (fabric ca)</a>
describes how to use fabric-ca-client to manage certificates.

<a  href="https://hyperledger-fabric.readthedocs.io/en/latest/network/network.html">fabric network as a concept</a>:
a look at the structure of the various pieces of a fabric network and how they interact.
______________________
from: https://hyperledger-fabric.readthedocs.io/en/latest/pluggable_endorsement_and_validation.html
core.yaml(@"peers") can declare also a mapping between the endorsement/validation logic name and the implementation to be run
_____________________________
https://hyperledger-fabric.readthedocs.io/en/latest/chaincode4ade.html
https://github.com/hyperledger/fabric/blob/release-1.3/core/chaincode/shim/interfaces.go
https://godoc.org/github.com/hyperledger/fabric/core/chaincode/shim
_____________________________
https://www.hyperledger.org/blog/2018/10/26/hyperledger-fabric-now-supports-ethereum
hyperledger fabric now supports ethereum
https://github.com/hyperledger/fabric-chaincode-evm/blob/master/examples/evm_smart_contracts.md
_______________________________
identity.js en el sdk de node contiene el código que firma las transacciones en cliente
antes de enviarlas al endorser  (class signer):
https://github.com/hyperledger/fabric-sdk-node/blob/release-1.4/fabric-client/lib/msp/identity.js
_______________________________


<a href="https://github.com/hyperledger/fabric/tree/master/devenv">vagrant dev.env</a>
__________________________
https://wiki.hyperledger.org/plugins/servlet/mobile?contentid=9109693#content/view/9109693

hyperledger aries is infrastructure for blockchain-rooted, peer-to-peer interactions. it includes a shared cryptographic wallet (the secure storage tech, not a ui) for blockchain clients as well as a communications protocol for allowing off-ledger interaction between those clients.  this project consumes the cryptographic support provided by hyperledger ursa, to provide secure secret management and decentralized key management functionality.

__________________
https://www.youtube.com/watch?v=0f9p9peehpq
hyperledger's integration with truffle - trufflecon 2019 (2019-09-28)
________________
https://fabric-dalf.readthedocs.io/en/latest/configtxgen.html
________________
<pre zoom labels="channel,">
<span xsmall>block creation parameters</span>
(from jean mathieu tchamdjeu)
configtxgen:
- you're right since hyperledger fabric uses proof of authority, there is no
  mining concept.
- but we have these basics parameters for the block creation:
    - batchtimeout: the amount of time to wait before creating a new block after
      receiving the first transaction to batch.
    - batchsize: controls the number of transactions batched into a block:
      - maxmessagecount: the maximum number of transactions to permit in a batch.
      - absolutemaxbytes: the absolute maximum number of bytes allowed for the
        serialized transactions in a batch.
      - preferredmaxbytes: the preferred maximum number of bytes allowed for the
        serialized transactions in a batch. a message larger than the preferred max
        bytes will result in a batch larger than preferred max bytes.

@[https://fabric-dalf.readthedocs.io/en/latest/configtxgen.html]

jean mathieu tchamdjeu
@[https://github.com/hyperledger/fabric/commit/4f90cd91674edb0926c41390ff80a9814a4e51c3]

@[https://stackoverflow.com/questions/49875309/attempt-to-achieve-high-throughput-in-hyperledger-fabric-network]
</pre>

<pre zoom labels="devops,tool,bootstrap">
<span xsmall>cello</span>
@[https://www.hyperledger.org/projects/cello]
hyperledger cello aims to serve as the operational dashboard for blockchain,
which reduces the effort required for creating, managing and using blockchains.
besides, it can also be used to facilitate creating blockchain as a service.
cello provides an operational console  for managing blockchain’s efficiently
and running on top of various infrastructures, e.g., baremetal, virtual
machine, and various container platforms.

see example:
@[https://stackoverflow.com/questions/49875309/attempt-to-achieve-high-throughput-in-hyperledger-fabric-network]
</pre>

_________________
- endorsement policies:
  - participant-list
  - policy attributes
<pre zoom labels="101,aaa,ca">
<a xsmall todo href="https://hyperledger-fabric-ca.readthedocs.io/en/latest/">fabric ca</a>
- alternative to openssl/cryptogen/... to generate msp crypto material
todo: ca-cli:
@[https://hyperledger-fabric.readthedocs.io/en/latest/commands/fabric-ca-commands.html]

env.var:
fabric_ca_home=/etc/hyperledger/fabric-ca-server
fabric_ca_server_tls_enabled=true
fabric_ca_server_tls_keyfile=/etc/.../355f8e6...cb_sk
fabric_ca_server_tls_certfile=/etc/...

docker image:
  hyperledger/fabric-ca        7054(ca) default fabric ca (linux ps) $ fabric-ca-server start --ca.certfile /etc/... --ca.keyfile /etc/... -b admin:adminpw -d
</pre>

<pre zoom labels="channel,advanced">
<span xsmall>configure leader election</span>
@[https://hyperledger-fabric.readthedocs.io/en/latest/channel_update_tutorial.html]
configuring leader election

this section is included as a general reference for understanding the leader 
election settings when adding organizations to a network after the initial 
channel configuration has completed. this sample defaults to dynamic leader 
election, which is set for all peers in the network.

newly joining peers are bootstrapped with the genesis block, which does not 
contain information about the organization that is being added in the channel 
configuration update. therefore new peers are not able to utilize gossip as 
they cannot verify blocks forwarded by other peers from their own organization 
until they get the configuration transaction which added the organization to 
the channel. newly added peers must therefore have one of the following 
configurations so that they receive blocks from the ordering service:

1. to utilize static leader mode, configure the peer to be an organization 
leader:

core_peer_gossip_useleaderelection=false
core_peer_gossip_orgleader=true

note

this configuration must be the same for all new peers added to the channel.

2. to utilize dynamic leader election, configure the peer to use leader 
election:

core_peer_gossip_useleaderelection=true
core_peer_gossip_orgleader=false

note

because peers of the newly added organization won’t be able to form 
membership view, this option will be similar to the static configuration, as 
each peer will start proclaiming itself to be a leader. however, once they get 
updated with the configuration transaction that adds the organization to the 
channel, there will be only one active leader for the organization. therefore, 
it is recommended to leverage this option if you eventually want the 
organization’s peers to utilize leader election.
install, define, and invoke chaincode

we can confirm that org3 is a member of mychannel by installing and invoking a 
chaincode on the channel. if the existing channel members have already 
committed a chaincode definition to the channel, a new organization can start 
using the chaincode by approving the chaincode definition.

note

these instructions use the fabric chaincode lifecycle introduced in the v2.0 
release. if you would like to use the previous lifecycle to install and 
instantiate a chaincode, visit the v1.4 version of the adding an org to a 
channel tutorial.

before we install a chaincode as org3, we can use the ./network.sh script to 
deploy the fabcar chaincode on the channel. open a new terminal outside the 
org3cli container and navigate to the test-network directory. you can then use 
use the test-network script to deploy the fabcar chaincode:

cd fabric-samples/test-network
./network.sh deploycc

the script will install the fabcar chaincode on the org1 and org2 peers, 
approve the chaincode definition for org1 and org2, and then commit the 
chaincode definition to the channel. once the chaincode definition has been 
committed to the channel, the fabcar chaincode is initialized and invoked to 
put initial data on the ledger. the commands below assume that we are still 
using the channel mychannel.

after the chaincode has been to deployed we can use the following steps to use 
invoke fabcar chaincode as org3. these steps can be completed from the 
test-network directory, without having to exec into org3cli container. copy and 
paste the following environment variables in your terminal in order to interact 
with the network as the org3 admin:

export path=${pwd}/../bin:${pwd}:$path
export fabric_cfg_path=$pwd/../config/
export core_peer_tls_enabled=true
export core_peer_localmspid="org3msp"
export 
core_peer_tls_rootcert_file=${pwd}/organizations/peerorganizations/org3.example.
com/peers/peer0.org3.ex.com/tls/ca.crt
export 
core_peer_mspconfigpath=${pwd}/organizations/peerorganizations/org3.ex.com/
users/admin@org3.ex.com/msp
export core_peer_address=localhost:11051

the first step is to package the fabcar chaincode:

peer lifecycle chaincode package fabcar.tar.gz --path ../chaincode/fabcar/go/ 
--lang golang --label fabcar_1

this command will create a chaincode package named fabcar.tar.gz, which we can 
install on the org3 peer. modify the command accordingly if the channel is 
running a chaincode written in java or node.js. issue the following command to 
install the chaincode package peer0.org3.ex.com:

peer lifecycle chaincode install fabcar.tar.gz

the next step is to approve the chaincode definition of fabcar as org3. org3 
needs to approve the same definition that org1 and org2 approved and committed 
to the channel. in order to invoke the chaincode, org3 needs to include the 
package identifier in the chaincode definition. you can find the package 
identifier by querying your peer:

peer lifecycle chaincode queryinstalled

you should see output similar to the following:

get installed chaincodes on peer:
package id: 
fabcar_1:25f28c212da84a8eca44d14cf12549d8f7b674a0d8288245561246fa90f7ab03, 
label: fabcar_1

we are going to need the package id in a future command, so lets go ahead and 
save it as an environment variable. paste the package id returned by the peer 
lifecycle chaincode queryinstalled command into the command below. the package 
id may not be the same for all users, so you need to complete this step using 
the package id returned from your console.

export 
cc_package_id=fabcar_1:25f28c212da84a8eca44d14cf12549d8f7b674a0d8288245561246fa9
0f7ab03

use the following command to approve a definition of the fabcar chaincode for 
org3:

# use the --package-id flag to provide the package identifier
# use the --init-required flag to request the ``init`` function be invoked to 
initialize the chaincode
peer lifecycle chaincode approveformyorg -o localhost:7050 
--orderertlshostnameoverride orderer.ex.com --channelid mychannel --name 
fabcar --version 1 --init-required --package-id $cc_package_id --sequence 1 
--tls true --cafile 
${pwd}/organizations/ordererorganizations/ex.com/orderers/orderer.example.c
om/msp/tlscacerts/tlsca.ex.com-cert.pem

you can use the peer lifecycle chaincode querycommitted command to check if the 
chaincode definition you have approved has already been committed to the 
channel.

# use the --name flag to select the chaincode whose definition you want to query
peer lifecycle chaincode querycommitted --channelid mychannel --name fabcar 
--cafile 
${pwd}/organizations/ordererorganizations/ex.com/orderers/orderer.example.c
om/msp/tlscacerts/tlsca.ex.com-cert.pem

a successful command will return information about the committed definition:

committed chaincode definition for chaincode 'fabcar' on channel 'mychannel':
version: 1, sequence: 1, endorsement plugin: escc, validation plugin: vscc, 
approvals: [org1msp: true, org2msp: true, org3msp: true]

org3 can use the fabcar chaincode after it approves the chaincode definition 
that was committed to the channel. the chaincode definition uses the default 
endorsement policy, which requires a majority of organizations on the channel 
endorse a transaction. this implies that if an organization is added to or 
removed from the channel, the endorsement policy will be updated automatically. 
we previously needed endorsements from org1 and org2 (2 out of 2). now we need 
endorsements from two organizations out of org1, org2, and org3 (2 out of 3).

you can query the chaincode to ensure that it has started on the org3 peer. 
note that you may need to wait for the chaincode container to start.

peer chaincode query -c mychannel -n fabcar -c '{"args":["queryallcars"]}'

you should see the initial list of cars that were added to the ledger as a 
response.

now, invoke the chaincode to add a new car to the ledger. in the command below, 
we target a peer in org1 and org3 to collect a sufficient number of 
endorsements.

peer chaincode invoke -o localhost:7050 --orderertlshostnameoverride 
orderer.ex.com --tls true --cafile 
${pwd}/organizations/ordererorganizations/ex.com/orderers/orderer.example.c
om/msp/tlscacerts/tlsca.ex.com-cert.pem -c mychannel -n fabcar 
--peeraddresses localhost:7051 --tlsrootcertfiles 
${pwd}/organizations/peerorganizations/org1.ex.com/peers/peer0.org1.example
.com/tls/ca.crt --peeraddresses localhost:11051 --tlsrootcertfiles 
${pwd}/organizations/peerorganizations/org3.ex.com/peers/peer0.org3.example
.com/tls/ca.crt -c 
'{"function":"createcar","args":["car11","honda","accord","black","tom"]}'

we can query again to see the new car, “car11” on the our the ledger:

peer chaincode query -c mychannel -n fabcar -c '{"args":["querycar","car11"]}'

conclusion

the channel configuration update process is indeed quite involved, but there is 
a logical method to the various steps. the endgame is to form a delta 
transaction object represented in protobuf binary format and then acquire the 
requisite number of admin signatures such that the channel configuration update 
transaction fulfills the channel’s modification policy.

the configtxlator and jq tools, along with the peer channel commands, provide 
us with the functionality to accomplish this task.
updating the channel config to include an org3 anchor peer (optional)

the org3 peers were able to establish gossip connection to the org1 and org2 
peers since org1 and org2 had anchor peers defined in the channel 
configuration. likewise newly added organizations like org3 should also define 
their anchor peers in the channel configuration so that any new peers from 
other organizations can directly discover an org3 peer. in this section, we 
will make a channel configuration update to define an org3 anchor peer. the 
process will be similar to the previous configuration update, therefore we’ll 
go faster this time.

if you don’t have it open, exec back into the org3cli container:

docker exec -it org3cli bash

export the $orderer_ca and $channel_name variables if they are not already set:

export 
orderer_ca=/opt/gopath/src/github.com/hyperledger/fabric/peer/organizations/orde
rerorganizations/ex.com/orderers/orderer.ex.com/msp/tlscacerts/tlsca.e
xample.com-cert.pem
export channel_name=mychannel

as before, we will fetch the latest channel configuration to get started. 
inside the org3cli container, fetch the most recent config block for the 
channel, using the peer channel fetch command.

peer channel fetch config config_block.pb -o orderer.ex.com:7050 -c 
$channel_name --tls --cafile $orderer_ca

after fetching the config block we will want to convert it into json format. to 
do this we will use the configtxlator tool, as done previously when adding org3 
to the channel. when converting it we need to remove all the headers, metadata, 
and signatures that are not required to update org3 to include an anchor peer 
by using the jq tool. this information will be reincorporated later before we 
proceed to update the channel configuration.

configtxlator proto_decode --input config_block.pb --type common.block | jq 
.data.data[0].payload.data.config > config.json

the config.json is the now trimmed json representing the latest channel 
configuration that we will update.

using the jq tool again, we will update the configuration json with the org3 
anchor peer we want to add.

jq '.channel_group.groups.application.groups.org3msp.values += 
{"anchorpeers":{"mod_policy": "admins","value":{"anchor_peers": [{"host": 
"peer0.org3.ex.com","port": 11051}]},"version": "0"}}' config.json > 
modified_anchor_config.json

we now have two json files, one for the current channel configuration, 
config.json, and one for the desired channel configuration 
modified_anchor_config.json. next we convert each of these back into protobuf 
format and calculate the delta between the two.

translate config.json back into protobuf format as config.pb

configtxlator proto_encode --input config.json --type common.config --output 
config.pb

translate the modified_anchor_config.json into protobuf format as 
modified_anchor_config.pb

configtxlator proto_encode --input modified_anchor_config.json --type 
common.config --output modified_anchor_config.pb

calculate the delta between the two protobuf formatted configurations.

configtxlator compute_update --channel_id $channel_name --original config.pb 
--updated modified_anchor_config.pb --output anchor_update.pb

now that we have the desired update to the channel we must wrap it in an 
envelope message so that it can be properly read. to do this we must first 
convert the protobuf back into a json that can be wrapped.

we will use the configtxlator command again to convert anchor_update.pb into 
anchor_update.json

configtxlator proto_decode --input anchor_update.pb --type common.configupdate 
| jq . > anchor_update.json

next we will wrap the update in an envelope message, restoring the previously 
stripped away header, outputting it to anchor_update_in_envelope.json

echo '{"payload":{"header":{"channel_header":{"channel_id":"'$channel_name'", 
"type":2}},"data":{"config_update":'$(cat anchor_update.json)'}}}' | jq . > 
anchor_update_in_envelope.json

now that we have reincorporated the envelope we need to convert it to a 
protobuf so it can be properly signed and submitted to the orderer for the 
update.

configtxlator proto_encode --input anchor_update_in_envelope.json --type 
common.envelope --output anchor_update_in_envelope.pb

now that the update has been properly formatted it is time to sign off and 
submit it. since this is only an update to org3 we only need to have org3 sign 
off on the update. run the following commands to make sure that we are 
operating as the org3 admin:

# you can issue all of these commands at once

export core_peer_localmspid="org3msp"
export 
core_peer_tls_rootcert_file=/opt/gopath/src/github.com/hyperledger/fabric/peer/o
rganizations/peerorganizations/org3.ex.com/peers/peer0.org3.ex.com/tls
/ca.crt
export 
core_peer_mspconfigpath=/opt/gopath/src/github.com/hyperledger/fabric/peer/organ
izations/peerorganizations/org3.ex.com/users/admin@org3.ex.com/msp
export core_peer_address=peer0.org3.ex.com:11051

we can now just use the peer channel update command to sign the update as the 
org3 admin before submitting it to the orderer.

peer channel update -f anchor_update_in_envelope.pb -c $channel_name -o 
orderer.ex.com:7050 --tls --cafile $orderer_ca

the orderer receives the config update request and cuts a block with the 
updated configuration. as peers receive the block, they will process the 
configuration updates.

inspect the logs for one of the peers. while processing the configuration 
transaction from the new block, you will see gossip re-establish connections 
using the new anchor peer for org3. this is proof that the configuration update 
has been successfully applied!

docker logs -f peer0.org1.ex.com

2019-06-12 17:08:57.924 utc [gossip.gossip] learnanchorpeers -> info 89a 
learning about the configured anchor peers of org1msp for channel mychannel : 
[{peer0.org1.ex.com 7051}]
2019-06-12 17:08:57.926 utc [gossip.gossip] learnanchorpeers -> info 89b 
learning about the configured anchor peers of org2msp for channel mychannel : 
[{peer0.org2.ex.com 9051}]
2019-06-12 17:08:57.926 utc [gossip.gossip] learnanchorpeers -> info 89c 
learning about the configured anchor peers of org3msp for channel mychannel : 
[{peer0.org3.ex.com 11051}]

congratulations, you have now made two configuration updates — one to add 
org3 to the channel, and a second to define an anchor peer for org3.

</pre>

<pre zoom labels="todo">
<span xsmall>propose message format</span>
https://hyperledger-fabric.readthedocs.io/en/release-1.4/arch-deep-dive.html


2.1. The client creates a transaction and sends it to endorsing peers of its choice

To invoke a transaction, the client sends a PROPOSE message to a set of endorsing peers of its choice (possibly not at the same time - see Sections 2.1.2. and 2.3.). The set of endorsing peers for a given chaincodeID is made available to client via peer, which in turn knows the set of endorsing peers from endorsement policy (see Section 3). For example, the transaction could be sent to all endorsers of a given chaincodeID. That said, some endorsers could be offline, others may object and choose not to endorse the transaction. The submitting client tries to satisfy the policy expression with the endorsers available.

In the following, we first detail PROPOSE message format and then discuss possible patterns of interaction between submitting client and endorsers.
2.1.1. PROPOSE message format

The format of a PROPOSE message is <PROPOSE,tx,[anchor]>, where tx is a mandatory and anchor optional argument explained in the following.

    tx=<clientID,chaincodeID,txPayload,timestamp,clientSig>, where
        clientID is an ID of the submitting client,
        chaincodeID refers to the chaincode to which the transaction pertains,
        txPayload is the payload containing the submitted transaction itself,
        timestamp is a monotonically increasing (for every new transaction) integer maintained by the client,
        clientSig is signature of a client on other fields of tx.

    The details of txPayload will differ between invoke transactions and deploy transactions (i.e., invoke transactions referring to a deploy-specific system chaincode). For an invoke transaction, txPayload would consist of two fields
        txPayload = <operation, metadata>, where
            operation denotes the chaincode operation (function) and arguments,
            metadata denotes attributes related to the invocation.

    For a deploy transaction, txPayload would consist of three fields
        txPayload = <source, metadata, policies>, where
            source denotes the source code of the chaincode,
            metadata denotes attributes related to the chaincode and application,
            policies contains policies related to the chaincode that are accessible to all peers, such as the endorsement policy. Note that endorsement policies are not supplied with txPayload in a deploy transaction, but txPayload of a deploy contains endorsement policy ID and its parameters (see Section 3).

    anchor contains read version dependencies, or more specifically, key-version pairs (i.e., anchor is a subset of KxN), that binds or “anchors” the PROPOSE request to specified versions of keys in a KVS (see Section 1.2.). If the client specifies the anchor argument, an endorser endorses a transaction only upon read version numbers of corresponding keys in its local KVS match anchor (see Section 2.2. for more details).

Cryptographic hash of tx is used by all nodes as a unique transaction identifier tid (i.e., tid=HASH(tx)). The client stores tid in memory and waits for responses from endorsing peers.
</pre>
_______________________
@adlrocha - Performance Best Practices in Hyperledger Fabric IV: SDK - @adlrocha Weekly Newsletter
https://adlrocha.substack.com/p/adlrocha-performance-best-practices-50a 
_______________________
<pre zoom labels="TODO">
<span xsmall>Block Internals</span>
RE: @[https://blog.quillhash.com/2019/03/19/ethereum-or-hyperledger-fabric/]

Fabric’s block segments:

   typeºBlockºstruct {
 ┌      Header   *BlockHeader     ← small segment compared to Data
 |      Data     *BlockData     
┌|      Metadata *BlockMetadata   ← small segment compared to Data
·|  }
·|
·└→ typeºBlockHeaderºstruct {
·      Number       uint64   ←  8 bytes the unique block number. (0 => Genesis Block)
·      PreviousHash []byte   ← 32 bytes hash of prev. block's header.
·      DataHash     []byte   ← 32 bytes hash of current block data segment
·  }                           ^^
·                              52 bytes length total
·
└→ type BlockMetadata struct { ← "stores four metadata", each as a byte array
       Metadata [ ][ ] byte 
   }             ^
   ┌─────────────┘
   0 SIGNATURES         : signature on the block creation.           
   1 LAST_CONFIG        : reference to the last configuration block. 
   2 TRANSACTIONS_FILTER: valid and invalid transactions in a block. 
   3 ORDERER            : last offset persisted (kafka Order MetaDa).
   ^ 
   └ 0,1,3 added by the ordering service.
   └ For 1 and 3 the last configuration block number and last offset
   · persisted are set to Value · field in next struct: 
   · type Metadata struct {              ┌→ type MetadataSignature struct {
   ·     Value      []byte               |    SignatureHeader []byte 
   ·     Signatures []*MetadataSignature←┘    Signature       []byte 
   · }                                      }
   ·
   · type SignatureHeader struct {   
   ·     Creator []byte  ← x.509 cert. + pub.key + MSP_who_issued_identity
   ·     Nonce   []byte  ← "random bytes"
   · }
   · ^
   · SIGNATURE metadata (index 0) uses the above 3 structures but set
   · Metadata.Value to nil as it wants to add just the signature on
   · block creation.
   ·
   └ 2 (TRANSACTION_FILTER) added by the committer after validating the
     transaction based on the endorsement policy, verification of 
     read-write set, etc… 
     TRANSACTION_FILTER is a byte array of size equal to the number
     of transactions in the block:
     - For each TX, committer sets a validation code in the 
       byte array appropriately to represent the validation result.
       validations codes:
       TxValidationCode_VALID                          0
       TxValidationCode_NIL_ENVELOPE                   1
       TxValidationCode_BAD_PAYLOAD                    2
       TxValidationCode_BAD_COMMON_HEADER              3
       TxValidationCode_BAD_CREATOR_SIGNATURE          4
       TxValidationCode_INVALID_ENDORSER_TRANSACTION   5
       TxValidationCode_INVALID_CONFIG_TRANSACTION     6
       TxValidationCode_UNSUPPORTED_TX_PAYLOAD         7
       TxValidationCode_BAD_PROPOSAL_TXID              8
       TxValidationCode_DUPLICATE_TXID                 9
       TxValidationCode_ENDORSEMENT_POLICY_FAILURE    10
       TxValidationCode_MVCC_READ_CONFLICT            11
       TxValidationCode_PHANTOM_READ_CONFLICT         12
       TxValidationCode_UNKNOWN_TX_TYPE               13
       TxValidationCode_TARGET_CHAIN_NOT_FOUND        14
       TxValidationCode_MARSHAL_TX_ERROR              15
       TxValidationCode_NIL_TXACTION                  16
       TxValidationCode_INVALID_OTHER_REASON         255
</pre>

<pre zoom labels="TODO">
<span xsmall>Telefonica TrustOS</span>
@[https://trustos.readthedocs.io/en/latest/]

Final BCK Use-cases on top of Fabric + Ethereum MainNet.
</pre>

<pre zoom labels="TODO">
<span xsmall>Fabric 2.2 course</span>
"""
 A few months have passed, and I've finished the course on 
Enterprise Blockchain Technologies - with a focus on Fabric v2.2:
 https://github.com/hyperledger-labs/university-course. 

Please feel free to leverage these materials as you prefer.

Also, I'm looking for contributors to extend this course, either the 
Hyperledger Fabric topics or other Hyperledger technologies. Feel 
free to reach out!

"""

</pre>

https://www.securing.pl/en/four-common-pitfalls-of-hyperledger-implementation/

https://github.com/tldr-pages/tldr/blob/master/pages/common/minifab.md
Utility tool that automates the setup and deployment of Hyperledger 
Fabric networks. More information: 
https://github.com/hyperledger-labs/minifabric.



